```text
███████╗ ██████╗ ███╗   ██╗████████╗ █████╗  ██████╗
██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██╔══██╗██╔════╝
███████╗██║   ██║██╔██╗ ██║   ██║   ███████║██║  ███╗
╚════██║██║   ██║██║╚██╗██║   ██║   ██╔══██║██║   ██║
███████║╚██████╔╝██║ ╚████║   ██║   ██║  ██║╚██████╔╝
╚══════╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝
```

a C++ interpreter and analysis-focused code execution harness

## Requirements

- Linux or macOS
- CMake
- Ninja
- Latest stable LLVM toolchain (>= 20), including:
  - `clang++` (C++23 compiler; resolved via build config)
  - `llvm-mca` (for `:mca`; currently unavailable on macOS arm64)
  - `llvm-objdump`
  - `llvm-nm` (for symbol discovery/indexing)
  - macOS install: `brew install llvm@21`

## Build

### Linux
Note: compiler paths may need to be adjusted per your local configuration

```bash
mkdir -p build
cd build
cmake .. -G Ninja \
    -DCMAKE_C_COMPILER=clang \
    -DCMAKE_CXX_COMPILER=clang++
ninja -v
```

### MacOS

```bash
mkdir -p build
cd build
cmake .. -G Ninja
ninja -v
```

### Binary output:

```bash
./build/sontag
```

### Running tests:

```bash
./build/tests/alltests
```

## Quickstart

```text
:decl int value = 64;
:decl int values[2];
values[0] = value * value;
values[1] = value * 2;
:show all
:symbols
:config build.opt=O0
:dump
:asm
:ir
:mca
```

### Output:

```bash
sontag > :decl int value = 64;
stored decl #1 -> state: valid
sontag > :decl int values[2];
stored decl #2 -> state: valid
sontag > values[0] = value * value;
stored cell #1 -> state: valid
sontag > values[1] = value * 2;
stored cell #2 -> state: valid
sontag > :show all
// generated by sontag m1
// decl cell 1
int value = 64;

// decl cell 2
int values[2];

int __sontag_main() {
    // exec cell 1
    values[0] = value * value;

    // exec cell 2
    values[1] = value * 2;

    return 0;
}
sontag >
```

## Current Functionality

- interactive C++ cell entry in a REPL loop
- top-level declaration cells (`:decl`) and executable cells
- file ingestion commands:
  - `:declfile <path>` loads full file text as one declarative cell
  - `:file <path>` AST-splits a source file into declarative prefix + driver body (`main` or `__sontag_main`)
  - `:openfile <path>` opens an editor (configured editor or `VISUAL`/`EDITOR`, fallback `hx` -> `neovim`/`nvim` -> `vim` -> `nano`), runs `clang-format -i`, then imports with `:file` semantics
- clear/reset commands:
  - `:clear` clears the terminal screen
  - `:reset` clears active code state (cells + transactions) and rebinds `current` to empty
  - `:reset last` undoes the most recent mutation transaction (single line or full file import)
  - `:reset snapshots` clears named snapshots and reinitializes snapshot storage to `current`
  - `:reset file <path>` undoes the most recent matching file import transaction from either `:file` or `:declfile`
- config commands:
  - `:config` opens an interactive category menu (`build`, `ui`, `session`, `editor`)
    - selecting a category prints that category and opens an interactive key menu
    - selecting a bare key (for example `output`) opens a `key=` value prompt
    - enum-like keys support value completion in that prompt (for example `output -> table|json`, `color_scheme -> classic|vaporwave`)
    - selecting `key=value` from the key menu applies immediately
  - `:config <category>` prints category keys/values
  - `:config <key>=<value>` mutates a single setting
  - `:config reset` restores all mutable settings to defaults
- generated translation unit preview (`:show all`)
- symbol listing from compiled output (`:symbols`)
- assembly output (`:asm`)
- object disassembly via `llvm-objdump` (`:dump`)
- LLVM IR output (`:ir`)
- compiler diagnostics output (`:diag`)
- microarchitecture analysis via `llvm-mca` (`:mca`, unavailable on macOS arm64)
- optimization delta analysis (`:delta`) with:
  - pairwise `O0 -> target` and spectrum `O0..target` opcode-aligned operation comparison (default target: `O2`)
  - snapshot pairwise comparison (`:delta <snapshot>`) with `current` as baseline and the snapshot label as target
- graph generation (`:graph <subcommand>`)
  - control-flow graphs (`:graph cfg`)
  - function call graphs (`:graph call`)
  - def-use graphs (`:graph defuse`)
- structured visualization data export (`:inspect <subcommand>`)
  - source/IR/asm line-map data (`:inspect asm`)
  - mca summary/heatmap data (`:inspect mca`)

## How Input Works

- `:decl <code>` stores top-level declarations (includes, globals, functions).
- `:declfile <path>` appends an entire file as one declarative cell.
- `:file <path>` appends to current state by loading a file and extracting:
  - top-level declarative text before the driver function
  - one executable cell from the selected driver body
  - if both `main` and `__sontag_main` exist, import fails
  - if neither exists, import fails and suggests `:declfile`
- `:openfile <path>` opens/edit a file in-terminal, applies repository `.clang-format`, then imports through the same pipeline as `:file`.
- non-command input stores executable cells in synthesized `__sontag_main()`.
- press `Shift+Tab` (or `Ctrl+Enter`) to insert a newline while composing a multi-line cell.
- use `:show all` to inspect the full generated source in order: declarations first, then executable cells wrapped in the synthesized function.
- all mutating commands validate atomically; on failure, state is unchanged.

## Config Menu Flow

- `:config`:
  - choose category (`ui`, `build`, `session`, `editor`, `q`)
  - category values are printed
  - choose either:
    - a bare key, which opens a `key=` value prompt
    - a direct `key=value` entry
- example:
  - `:config` -> `ui` -> `output` -> `json`
  - result: `updated ui.output=json`

## Reset Semantics

- state mutations are tracked as transactions:
  - single-line mutations (`:decl ...` or plain executable input) are one transaction
  - `:file <path>` and `:declfile <path>` are import transactions
- `:clear` is screen-only (no subcommands).
- `:reset` clears persisted cells and transactions, keeps named snapshots, and rebinds `current` to empty state.
- `:reset last` removes the most recent successful transaction.
- `:reset snapshots` clears all named snapshots and reinitializes snapshot storage to `current`.
- `:reset file <path>` removes the most recent successful import transaction matching the normalized path, whether imported with `:file` or `:declfile`.
- successful mutation output uses:
  - `... -> state: valid`
- failed mutation output ends with:
  - `state unchanged`

## Snapshots and `@last` tag

- a snapshot is a persisted point-in-time code state (all current `:decl` cells + executable cells) identified by cell count.
- `:mark <name>` records a named snapshot marker at the current state.
- `:snapshots` lists recorded markers in the session.
- `@last` in analysis commands means analyze the latest/current snapshot state; passed by default

## Analysis Functionalities

- `:symbols` compiles the current snapshot to an object file, runs symbol discovery, and prints symbol kind/name entries.
- `:asm [symbol|@last]` compiles the current snapshot to assembly and prints full assembly text or a symbol-scoped assembly block.
- `:dump [symbol|@last]` compiles the current snapshot to an object file, disassembles it, and prints instruction-level object disassembly.
- `:ir [symbol|@last]` compiles the current snapshot with LLVM IR emission and prints full IR text or a symbol-scoped IR definition.
- `:diag [symbol|@last]` runs compile diagnostics on the current snapshot and prints compiler errors/warnings (optionally filtered by symbol).
- `:mca [symbol|@last]` compiles to assembly, runs microarchitecture analysis, and prints throughput/latency/resource-pressure analysis text.
- `:mca` does not operate on data symbols (for example `[D]`/`[B]` entries from `:symbols`).
- `:mca` and `:inspect mca ...` are currently unavailable on macOS arm64 due to an upstream `llvm-mca` crash while parsing Darwin assembly directives.
- `:delta [spectrum] [target_opt] [symbol|@last]` runs either pairwise (`O0 -> target_opt`) or spectrum (`O0..target_opt`) optimization comparison, reports opcode UID mapping, and prints per-level operation streams.
- `:delta <snapshot> [target_opt]` runs pairwise current-vs-snapshot comparison at one optimization level (default: current `opt_level`), with labels `current` and `<snapshot>`.
- `:inspect asm [symbol|@last]` emits structured JSON containing aligned source/IR/asm line records for downstream tooling.
- `:inspect mca [summary|heatmap] [symbol|@last]` emits structured JSON from `llvm-mca` output and prints a compact terminal summary.
- `:graph cfg [symbol|@last]` compiles to LLVM IR, builds a function-scoped control-flow graph, and emits graph summary + DOT artifact (with optional rendered image).
- `:graph call [symbol|@last]` compiles to LLVM IR, builds a root-scoped function call graph, and emits graph summary + DOT artifact (with optional rendered image).
- `:graph defuse [symbol|@last]` compiles to LLVM IR, builds a function-scoped def-use graph, and emits graph summary + DOT artifact (with optional rendered image).

## `:delta`

Use `:delta` for instruction-stream comparison on the current snapshot.

Modes:
- `:delta [target_opt] [symbol|@last]`: pairwise mode (`O0 -> target_opt`), default target is `O2`.
- `:delta spectrum [target_opt] [symbol|@last]`: spectrum mode (`O0..target_opt`), default upper bound is `O2`.
- `:delta <snapshot> [target_opt]`: pairwise current-vs-snapshot mode at one optimization level (default: current `opt_level`).

Output summary fields:
- `mode`: `pairwise` or `spectrum`
- `baseline` / `target`: range endpoints (`O*` labels in optimization mode, `current`/snapshot labels in snapshot mode)
- `changes`: unchanged/modified/inserted/removed/moved counters
- `levels`: per-level success, exit code, operation count, opcode counts
- `metrics`: canonical per-level metric table; on macOS arm64, `mca.*` rows are omitted.

Side-by-side row markers:
- `=` unchanged opcode UID relative to baseline
- `*` modified opcode UID relative to baseline
- `-` line absent at that level for the aligned row
- `+` line inserted at that level beyond baseline coverage

Alignment behavior:
- pairwise: first matching normalized operation key (`mnemonic|dst_bucket|src_bucket`) between baseline and target
- spectrum: earliest shared baseline normalized operation key across all compared levels (by average target index)

### Examples:

#### File:
```c++
// ./temp/objdump_loop.cpp

int value = 64;
int values[4];

constexpr int add(int a, int b) {
    return a + b;
}

constexpr int fold(int a, int b, int c) {
    if (--c > 0) {
        return fold(a, add(a, b), c);
    }
    return add(a, b);
}

int __sontag_main() {
    auto double_value = value * 2;
    values[0] = value;
    values[1] = double_value;
    values[2] = add(values[0], values[1]);
    values[3] = fold(values[0], values[1], 3);

    return 0;
}
```

#### Input:
```bash
sontag > :file ./temp/objdump_loop.cpp
loaded file /home/dan/dev/sontag/build/temp/objdump_loop.cpp (decl=1, exec=1) -> state: valid
sontag > :delta spectrum
delta: success
mode: spectrum
symbol: __sontag_main()
baseline: O0
target: O2
changes: unchanged=3 modified=7 inserted=0 removed=3 moved=0
opcode table entries: 8
levels:
  O0 success=true | operations=13 | opcodes: push(1) mov(9) sub(1) shl(1) call(1)
  O1 success=true | operations=9 | opcodes: push(1) mov(5) lea(2) call(1)
  O2 success=true | operations=10 | opcodes: mov(5) lea(3) xor(1) ret(1)
spectrum (O0 -> O2):
        alignment anchors: O0[3] <-> O1[1] <-> O2[0]
          O0                                | O1                              | O2                             
        ------------------------------------+---------------------------------+--------------------------------
        - [0] 1:push rbp                    | -                               | -                              
        - [1] 2:mov rbp, rsp                | -                               | -                              
        - [2] 3:sub rsp, 0x10               | * [0] 1:push rax                | -                              
        = [3] 2:mov eax, dword              | = [1] 2:mov edi, dword          | = [0] 2:mov eax, dword         
        * [4] 4:shl eax                     | * [2] 6:lea esi, [rdi + rdi]    | * [1] 6:lea ecx, [rax + rax]   
        = [5] 2:mov dword [rbp - 0x4], eax  | = [3] 2:mov dword, edi          | = [2] 2:mov dword, eax         
        = [6] 2:mov eax, dword              | = [4] 2:mov dword, esi          | = [3] 2:mov dword, ecx         
        * [7] 2:mov dword, eax              | * [5] 6:lea eax, [rdi + 2*rdi]  | * [4] 6:lea ecx, [rax + 2*rax] 
        = [8] 2:mov eax, dword [rbp - 0x4]  | = [6] 2:mov dword, eax          | = [5] 2:mov dword, ecx         
        * [9] 2:mov dword, eax              | = [7] 2:mov edx, 0x3            | * [6] 6:lea eax, [rax + 4*rax] 
        * [10] 2:mov edi, dword             | * [8] 5:call <l0>               | = [7] 2:mov dword, eax         
        - [11] 2:mov esi, dword             | -                               | * [8] 7:xor eax, eax           
        - [12] 5:call <l0>                  | -                               | * [9] 8:ret                    
metrics:
          metric                                       | O0         | O1         | O2        
        -----------------------------------------------+------------+------------+-----------
          size.symbol_text_bytes (bytes)               | 57         | 41         | 42        
          asm.insn_total (count)                       | 13         | 9          | 10        
          asm.mem_ops_ratio (ratio)                    | 0.6154     | 0.6667     | 0.8000    
          asm.call_count (count)                       | 1          | 1          | 0         
          asm.branch_density (ratio)                   | 0.0000     | 0.0000     | 0.1000    
          asm.bb_count (count)                         | 1          | 1          | 1         
          asm.stack_frame_bytes (bytes)                | 16         | 0          | 0         
          asm.spill_fill_count (count)                 | 2          | 0          | 0         
          build.compile_time_ms (ms)                   | 45.038     | 46.196     | 45.477    
          mca.block_rthroughput (cycles_per_iteration) | 7.0000     | 5.0000     | 4.0000    
          mca.ipc (inst_per_cycle)                     | 1.9100     | 1.5000     | 2.4500    
          mca.total_uops (count)                       | 2300       | 1400       | 1200      
          mca.rf_integer_max_mappings (count)          | 155        | 90         | 64        
          mca.rf_fp_max_mappings (count)               | 0          | 0          | 0 
```

## `:graph`

Use `:graph <subcommand>` for graph-oriented analysis outputs.

Supported subcommands:
- `cfg`: function-scoped control-flow graph.
- `call`: root-scoped function call graph.
- Add new `:graph` subcommands to this list as they are implemented.

Examples:

```text
:graph cfg
:graph cfg __sontag_main
:graph call
:graph call __sontag_main
```

Output includes:
- `cfg`:
  - `function`: resolved function used to build the CFG
  - `blocks`: number of CFG blocks
  - `edges`: number of CFG edges
  - `dot`: path to the DOT artifact in `artifacts/graphs/cfg`
  - `rendered`: rendered graph path (or `<none>` if rendering is unavailable)
- `call`:
  - `root`: resolved root function used to build the call graph
  - `nodes`: number of graph nodes
  - `edges`: number of call edges
  - `dot`: path to the DOT artifact in `artifacts/graphs/call`
  - `rendered`: rendered graph path (or `<none>` if rendering is unavailable)

## `:inspect`

Use `:inspect <subcommand>` for structured visualization data payloads.

Supported subcommands:
- `asm`: source/IR/asm alignment payload (JSON).
- `mca summary`: parsed llvm-mca summary payload (JSON).
- `mca heatmap`: parsed llvm-mca resource-pressure payload (JSON).

Examples:

```text
:inspect asm
:inspect asm __sontag_main
:inspect mca
:inspect mca summary
:inspect mca heatmap __sontag_main
```

Notes:
- `:inspect` commands emit JSON artifacts under `artifacts/inspect/...` and print a compact terminal summary.
- `:inspect` commands do not generate rendered image files.
- `:inspect mca ...` is currently unavailable on macOS arm64 (same `llvm-mca` upstream crash as `:mca`).
- `color_scheme` config options currently supported are `classic` (default) and `vaporwave`.
