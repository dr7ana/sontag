#include "sontag/analysis.hpp"

#include "sontag/format.hpp"

#include <cxxabi.h>
extern "C" {
#include <fcntl.h>
#include <sys/wait.h>
#include <unistd.h>
}

#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <functional>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <system_error>
#include <vector>

namespace fs = std::filesystem;
using namespace sontag::literals;

namespace sontag {
    namespace detail {

        using namespace std::string_view_literals;

        static std::string read_text_file(const fs::path& path) {
            std::ifstream in{path};
            if (!in) {
                return {};
            }
            std::ostringstream ss{};
            ss << in.rdbuf();
            return ss.str();
        }

        static void write_text_file(const fs::path& path, std::string_view text) {
            std::ofstream out{path};
            if (!out) {
                throw std::runtime_error("failed to open file for write: {}"_format(path.string()));
            }
            out << text;
            if (!out) {
                throw std::runtime_error("failed to write file: {}"_format(path.string()));
            }
        }

        static std::string render_source(
                const std::vector<std::string>& decl_cells, const std::vector<std::string>& exec_cells) {
            std::ostringstream source{};
            source << "// generated by sontag m1\n";
            for (auto i = std::size_t{0}; i < decl_cells.size(); ++i) {
                source << "// decl cell " << (i + 1U) << '\n';
                source << decl_cells[i] << "\n\n";
            }

            source << "int __sontag_repl_main() {\n";
            for (auto i = std::size_t{0}; i < exec_cells.size(); ++i) {
                source << "    // exec cell " << (i + 1U) << '\n';
                source << "    " << exec_cells[i] << '\n';
                source << '\n';
            }
            source << "    return 0;\n";
            source << "}\n";
            return source.str();
        }

        static std::string make_artifact_id(const analysis_request& request, analysis_kind kind) {
            std::ostringstream key{};
            key << to_string(kind) << '\n';
            key << to_string(request.language_standard) << '\n';
            key << to_string(request.opt_level) << '\n';
            key << request.asm_syntax << '\n';
            if (request.symbol) {
                key << *request.symbol << '\n';
            }
            if (request.target_triple) {
                key << *request.target_triple << '\n';
            }
            if (request.cpu) {
                key << *request.cpu << '\n';
            }
            if (request.mca_cpu) {
                key << *request.mca_cpu << '\n';
            }
            for (const auto& cell : request.decl_cells) {
                key << "decl:" << cell << '\n';
            }
            for (const auto& cell : request.exec_cells) {
                key << "exec:" << cell << '\n';
            }

            auto hash_value = std::hash<std::string>{}(key.str());
            std::ostringstream id{};
            id << std::hex << hash_value;
            return id.str();
        }

        static void ensure_dir(const fs::path& path) {
            std::error_code ec{};
            fs::create_directories(path, ec);
            if (ec) {
                throw std::runtime_error("failed to create directory: {}"_format(path.string()));
            }
        }

        static int open_write_file(const fs::path& path) {
            auto fd = ::open(path.c_str(), O_CREAT | O_WRONLY | O_TRUNC, 0644);
            if (fd < 0) {
                throw std::runtime_error("failed to open file for write: {}"_format(path.string()));
            }
            return fd;
        }

        static int run_process(
                const std::vector<std::string>& args, const fs::path& stdout_path, const fs::path& stderr_path) {
            auto stdout_fd = open_write_file(stdout_path);
            auto stderr_fd = open_write_file(stderr_path);

            auto pid = ::fork();
            if (pid < 0) {
                ::close(stdout_fd);
                ::close(stderr_fd);
                throw std::runtime_error("fork failed");
            }

            if (pid == 0) {
                if (::dup2(stdout_fd, STDOUT_FILENO) < 0) {
                    _exit(127);
                }
                if (::dup2(stderr_fd, STDERR_FILENO) < 0) {
                    _exit(127);
                }

                ::close(stdout_fd);
                ::close(stderr_fd);

                std::vector<char*> argv{};
                argv.reserve(args.size() + 1U);
                for (const auto& arg : args) {
                    argv.push_back(const_cast<char*>(arg.c_str()));
                }
                argv.push_back(nullptr);

                ::execvp(argv[0], argv.data());
                _exit(127);
            }

            ::close(stdout_fd);
            ::close(stderr_fd);

            int status = 0;
            if (::waitpid(pid, &status, 0) < 0) {
                throw std::runtime_error("waitpid failed");
            }

            if (WIFEXITED(status)) {
                return WEXITSTATUS(status);
            }
            if (WIFSIGNALED(status)) {
                return 128 + WTERMSIG(status);
            }
            return 1;
        }

        namespace arg_tokens {
            static constexpr auto std_prefix = "-std="sv;
            static constexpr auto opt_prefix = "-"sv;
            static constexpr auto target_prefix = "--target="sv;
            static constexpr auto cpu_prefix = "-mcpu="sv;
            static constexpr auto mtriple_prefix = "-mtriple="sv;
            static constexpr auto llvm_mca_version_prefix = "llvm-mca-"sv;

            static constexpr auto compile_to_text = "-S"sv;
            static constexpr auto verbose_asm = "-fverbose-asm"sv;
            static constexpr auto intel_syntax = "-masm=intel"sv;
            static constexpr auto output_path = "-o"sv;
            static constexpr auto emit_llvm = "-emit-llvm"sv;
            static constexpr auto syntax_only = "-fsyntax-only"sv;
            static constexpr auto warn_all = "-Wall"sv;
            static constexpr auto warn_extra = "-Wextra"sv;
            static constexpr auto no_warn_error = "-Wno-error"sv;
            static constexpr auto no_unused_variable = "-Wno-unused-variable"sv;
            static constexpr auto no_unused_parameter = "-Wno-unused-parameter"sv;
            static constexpr auto no_unused_function = "-Wno-unused-function"sv;
            static constexpr auto version = "--version"sv;
            static constexpr auto clang_verbose = "-v"sv;
            static constexpr auto show_encoding = "--show-encoding"sv;
            static constexpr auto register_file_stats = "--register-file-stats"sv;
            static constexpr auto all_views = "--all-views"sv;
        }  // namespace arg_tokens

        static void append_prefixed_arg(
                std::vector<std::string>& args, std::string_view prefix, std::string_view value) {
            auto& arg = args.emplace_back(prefix);
            arg.append(value);
        }

        static void append_optional_prefixed_arg(
                std::vector<std::string>& args, std::string_view prefix, const std::optional<std::string>& value) {
            if (value) {
                append_prefixed_arg(args, prefix, *value);
            }
        }

        static std::vector<std::string> base_clang_args(const analysis_request& request) {
            std::vector<std::string> base_args{};
            base_args.reserve(9U);
            base_args.push_back(request.clang_path.string());
            append_prefixed_arg(base_args, arg_tokens::std_prefix, to_string(request.language_standard));
            append_prefixed_arg(base_args, arg_tokens::opt_prefix, to_string(request.opt_level));
            append_optional_prefixed_arg(base_args, arg_tokens::target_prefix, request.target_triple);
            append_optional_prefixed_arg(base_args, arg_tokens::cpu_prefix, request.cpu);
            base_args.emplace_back(arg_tokens::no_warn_error);
            base_args.emplace_back(arg_tokens::no_unused_variable);
            base_args.emplace_back(arg_tokens::no_unused_parameter);
            base_args.emplace_back(arg_tokens::no_unused_function);
            if (request.verbose) {
                base_args.emplace_back(arg_tokens::clang_verbose);
            }
            return base_args;
        }

        static std::vector<std::string> build_command(
                const analysis_request& request,
                analysis_kind kind,
                const fs::path& source_path,
                const fs::path& artifact_path) {
            auto base_args = base_clang_args(request);
            switch (kind) {
                case analysis_kind::asm_text:
                    base_args.emplace_back(arg_tokens::compile_to_text);
                    base_args.emplace_back(arg_tokens::verbose_asm);
                    if (request.asm_syntax == "intel") {
                        base_args.emplace_back(arg_tokens::intel_syntax);
                    }
                    base_args.push_back(source_path.string());
                    base_args.emplace_back(arg_tokens::output_path);
                    base_args.push_back(artifact_path.string());
                    break;
                case analysis_kind::ir:
                    base_args.emplace_back(arg_tokens::compile_to_text);
                    base_args.emplace_back(arg_tokens::emit_llvm);
                    base_args.push_back(source_path.string());
                    base_args.emplace_back(arg_tokens::output_path);
                    base_args.push_back(artifact_path.string());
                    break;
                case analysis_kind::diag:
                    base_args.emplace_back(arg_tokens::syntax_only);
                    base_args.emplace_back(arg_tokens::warn_all);
                    base_args.emplace_back(arg_tokens::warn_extra);
                    base_args.push_back(source_path.string());
                    break;
                case analysis_kind::mca:
                    break;
            }
            return base_args;
        }

        static std::vector<std::string> build_mca_command(
                const analysis_request& request, const fs::path& asm_path, std::string_view mca_executable) {
            std::vector<std::string> base_args{};
            base_args.push_back(std::string{mca_executable});

            append_optional_prefixed_arg(base_args, arg_tokens::mtriple_prefix, request.target_triple);

            if (request.mca_cpu) {
                append_prefixed_arg(base_args, arg_tokens::cpu_prefix, *request.mca_cpu);
            }
            else if (request.cpu) {
                append_prefixed_arg(base_args, arg_tokens::cpu_prefix, *request.cpu);
            }

            base_args.emplace_back(arg_tokens::show_encoding);
            base_args.emplace_back(arg_tokens::register_file_stats);
            if (request.verbose) {
                base_args.emplace_back(arg_tokens::all_views);
            }
            base_args.push_back(asm_path.string());
            return base_args;
        }

        static void append_unique(std::vector<std::string>& values, std::string value) {
            if (value.empty()) {
                return;
            }
            if (std::find(values.begin(), values.end(), value) == values.end()) {
                values.push_back(std::move(value));
            }
        }

        static std::string join_text(std::string_view lhs, std::string_view rhs) {
            if (rhs.empty()) {
                return std::string{lhs};
            }
            if (lhs.empty()) {
                return std::string{rhs};
            }
            if (lhs.ends_with('\n')) {
                return "{}{}"_format(lhs, rhs);
            }
            return "{}\n{}"_format(lhs, rhs);
        }

        static std::string join_with_separator(const std::vector<std::string>& values, std::string_view separator) {
            if (values.empty()) {
                return {};
            }

            auto joined = std::string{values.front()};
            for (auto i = std::size_t{1}; i < values.size(); ++i) {
                joined = "{}{}{}"_format(joined, separator, values[i]);
            }
            return joined;
        }

        static std::optional<std::string> parse_clang_name_suffix(std::string_view clang_name) {
            constexpr auto clang_xx_prefix = "clang++-"sv;
            constexpr auto clang_prefix = "clang-"sv;

            if (clang_name.rfind(clang_xx_prefix, 0U) == 0U && clang_name.size() > clang_xx_prefix.size()) {
                return std::string{clang_name.substr(clang_xx_prefix.size())};
            }
            if (clang_name.rfind(clang_prefix, 0U) == 0U && clang_name.size() > clang_prefix.size()) {
                return std::string{clang_name.substr(clang_prefix.size())};
            }
            return std::nullopt;
        }

        static std::optional<std::string> parse_clang_version_token(std::string_view clang_version_text) {
            auto marker = clang_version_text.find("version "sv);
            if (marker == std::string_view::npos) {
                return std::nullopt;
            }
            auto pos = marker + std::string_view{"version "sv}.size();
            while (pos < clang_version_text.size() &&
                   std::isspace(static_cast<unsigned char>(clang_version_text[pos]))) {
                ++pos;
            }
            if (pos >= clang_version_text.size()) {
                return std::nullopt;
            }

            auto token = std::string{};
            bool seen_digit = false;
            while (pos < clang_version_text.size()) {
                auto c = clang_version_text[pos];
                if (std::isdigit(static_cast<unsigned char>(c))) {
                    seen_digit = true;
                    token.push_back(c);
                    ++pos;
                    continue;
                }
                if (c == '.' && seen_digit) {
                    token.push_back(c);
                    ++pos;
                    continue;
                }
                break;
            }

            while (token.ends_with('.')) {
                token.pop_back();
            }
            if (token.empty()) {
                return std::nullopt;
            }
            return token;
        }

        static std::optional<std::string> parse_major_version(std::string_view version_token) {
            auto dot = version_token.find('.');
            auto major = dot == std::string_view::npos ? version_token : version_token.substr(0U, dot);
            if (major.empty()) {
                return std::nullopt;
            }
            return std::string{major};
        }

        static std::optional<std::string> query_clang_version_token(
                const analysis_request& request, const fs::path& temp_dir, std::string_view artifact_id) {
            auto stdout_path = temp_dir / std::string{artifact_id} / "clang_version.stdout.txt";
            auto stderr_path = temp_dir / std::string{artifact_id} / "clang_version.stderr.txt";
            ensure_dir(stdout_path.parent_path());

            std::vector<std::string> version_command{request.clang_path.string(), std::string{arg_tokens::version}};
            auto exit_code = run_process(version_command, stdout_path, stderr_path);
            if (exit_code != 0) {
                return std::nullopt;
            }

            auto version_text = read_text_file(stdout_path);
            return parse_clang_version_token(version_text);
        }

        static std::vector<std::string> build_mca_executable_candidates(
                const analysis_request& request, const fs::path& temp_dir, std::string_view artifact_id) {
            auto candidates = std::vector<std::string>{};
            append_unique(candidates, request.mca_path.string());
            if (request.mca_path.has_parent_path()) {
                return candidates;
            }

            auto suffixes = std::vector<std::string>{};
            if (auto from_name = parse_clang_name_suffix(request.clang_path.filename().string())) {
                append_unique(suffixes, *from_name);
            }
            if (auto from_version = query_clang_version_token(request, temp_dir, artifact_id)) {
                append_unique(suffixes, *from_version);
            }

            auto suffixes_with_major = std::vector<std::string>{};
            for (const auto& suffix : suffixes) {
                append_unique(suffixes_with_major, suffix);
                if (auto major = parse_major_version(suffix)) {
                    append_unique(suffixes_with_major, *major);
                }
            }

            auto clang_dir = request.clang_path.parent_path();
            auto configured_dir = request.mca_path.parent_path();
            for (const auto& suffix : suffixes_with_major) {
                auto mca_name = std::string{arg_tokens::llvm_mca_version_prefix};
                mca_name.append(suffix);
                append_unique(candidates, mca_name);
                if (!clang_dir.empty()) {
                    append_unique(candidates, (clang_dir / mca_name).string());
                }
                if (!configured_dir.empty()) {
                    append_unique(candidates, (configured_dir / mca_name).string());
                }
            }

            return candidates;
        }

        static bool starts_with(std::string_view value, std::string_view prefix) {
            return value.size() >= prefix.size() && value.substr(0U, prefix.size()) == prefix;
        }

        static std::vector<std::string> split_lines(const std::string& text) {
            std::vector<std::string> lines{};
            std::istringstream in{text};
            std::string line{};
            while (std::getline(in, line)) {
                lines.push_back(line);
            }
            return lines;
        }

        static bool contains_token(std::string_view haystack, std::string_view needle) {
            return haystack.find(needle) != std::string_view::npos;
        }

        static std::string_view trim_ascii(std::string_view value) {
            auto first = value.find_first_not_of(" \t\r\n");
            if (first == std::string_view::npos) {
                return {};
            }
            auto last = value.find_last_not_of(" \t\r\n");
            return value.substr(first, (last - first) + 1U);
        }

        static std::string demangle_symbol_name(std::string_view mangled) {
            int status = 0;
            auto* demangled_ptr = abi::__cxa_demangle(std::string{mangled}.c_str(), nullptr, nullptr, &status);
            if (demangled_ptr == nullptr || status != 0) {
                return std::string{mangled};
            }

            auto demangled = std::string{demangled_ptr};
            std::free(demangled_ptr);
            return demangled;
        }

        static std::optional<analysis_symbol> parse_nm_symbol_line(std::string_view line) {
            auto trimmed = trim_ascii(line);
            if (trimmed.empty()) {
                return std::nullopt;
            }

            auto name_start = trimmed.find_last_of(" \t");
            if (name_start == std::string_view::npos || name_start + 1U >= trimmed.size()) {
                return std::nullopt;
            }
            auto mangled = trim_ascii(trimmed.substr(name_start + 1U));
            if (mangled.empty()) {
                return std::nullopt;
            }

            auto prefix = trim_ascii(trimmed.substr(0U, name_start));
            if (prefix.empty()) {
                return std::nullopt;
            }

            auto kind_start = prefix.find_last_of(" \t");
            auto kind_token =
                    kind_start == std::string_view::npos ? prefix : trim_ascii(prefix.substr(kind_start + 1U));
            if (kind_token.size() != 1U) {
                return std::nullopt;
            }

            return analysis_symbol{
                    .kind = kind_token.front(),
                    .mangled = std::string{mangled},
                    .demangled = demangle_symbol_name(mangled)};
        }

        static std::vector<analysis_symbol> parse_nm_symbols(std::string_view nm_output) {
            std::vector<analysis_symbol> symbols{};
            auto in = std::istringstream{std::string{nm_output}};
            auto line = std::string{};

            while (std::getline(in, line)) {
                auto parsed = parse_nm_symbol_line(line);
                if (!parsed) {
                    continue;
                }
                symbols.push_back(std::move(*parsed));
            }

            std::sort(symbols.begin(), symbols.end(), [](const analysis_symbol& lhs, const analysis_symbol& rhs) {
                if (lhs.demangled != rhs.demangled) {
                    return lhs.demangled < rhs.demangled;
                }
                if (lhs.mangled != rhs.mangled) {
                    return lhs.mangled < rhs.mangled;
                }
                return lhs.kind < rhs.kind;
            });

            symbols.erase(
                    std::unique(
                            symbols.begin(),
                            symbols.end(),
                            [](const analysis_symbol& lhs, const analysis_symbol& rhs) {
                                return lhs.kind == rhs.kind && lhs.mangled == rhs.mangled;
                            }),
                    symbols.end());

            return symbols;
        }

        static std::optional<std::vector<analysis_symbol>> try_collect_defined_symbols(
                const analysis_request& request) {
            auto inputs_dir = request.session_dir / "artifacts" / "inputs";
            auto source_path = inputs_dir / "symbol_index.cpp";
            auto object_path = inputs_dir / "symbol_index.o";
            auto clang_stdout_path = inputs_dir / "symbol_index.clang.stdout.txt";
            auto clang_stderr_path = inputs_dir / "symbol_index.clang.stderr.txt";
            auto nm_stdout_path = inputs_dir / "symbol_index.nm.stdout.txt";
            auto nm_stderr_path = inputs_dir / "symbol_index.nm.stderr.txt";

            ensure_dir(inputs_dir);
            write_text_file(source_path, render_source(request.decl_cells, request.exec_cells));

            auto compile_args = base_clang_args(request);
            compile_args.emplace_back("-c");
            compile_args.push_back(source_path.string());
            compile_args.emplace_back("-o");
            compile_args.push_back(object_path.string());

            auto compile_exit = run_process(compile_args, clang_stdout_path, clang_stderr_path);
            if (compile_exit != 0) {
                return std::nullopt;
            }

            auto nm_args = std::vector<std::string>{"nm", "--defined-only", object_path.string()};
            auto nm_exit = run_process(nm_args, nm_stdout_path, nm_stderr_path);
            if (nm_exit != 0) {
                return std::nullopt;
            }

            auto nm_output = read_text_file(nm_stdout_path);
            return parse_nm_symbols(nm_output);
        }

        static std::optional<std::size_t> parse_header_line_number(
                std::string_view line, const std::string& source_path) {
            if (!starts_with(line, source_path)) {
                return std::nullopt;
            }
            auto first_colon = line.find(':', source_path.size());
            if (first_colon == std::string_view::npos) {
                return std::nullopt;
            }
            auto second_colon = line.find(':', first_colon + 1U);
            if (second_colon == std::string_view::npos) {
                return std::nullopt;
            }
            auto line_number_text = line.substr(first_colon + 1U, second_colon - (first_colon + 1U));
            if (line_number_text.empty()) {
                return std::nullopt;
            }
            std::size_t line_number = 0U;
            for (auto c : line_number_text) {
                if (!std::isdigit(static_cast<unsigned char>(c))) {
                    return std::nullopt;
                }
                line_number = (line_number * 10U) + static_cast<std::size_t>(c - '0');
            }
            return line_number;
        }

        static std::string filter_diag_by_symbol(
                const std::string& diagnostics_text,
                const std::string& source_text,
                const std::string& source_path,
                std::string_view symbol) {
            if (diagnostics_text.empty()) {
                return {};
            }

            auto source_lines = split_lines(source_text);

            auto symbol_ranges = std::vector<std::pair<std::size_t, std::size_t>>{};
            for (std::size_t i = 0U; i < source_lines.size(); ++i) {
                if (!contains_token(source_lines[i], symbol) || !contains_token(source_lines[i], "("sv)) {
                    continue;
                }

                std::size_t j = i;
                bool found_open = false;
                int depth = 0;
                for (; j < source_lines.size(); ++j) {
                    for (auto c : source_lines[j]) {
                        if (c == '{') {
                            found_open = true;
                            ++depth;
                        }
                        else if (c == '}') {
                            --depth;
                        }
                    }
                    if (found_open && depth <= 0) {
                        symbol_ranges.push_back({i + 1U, j + 1U});
                        i = j;
                        break;
                    }
                }
            }
            auto diag_lines = split_lines(diagnostics_text);
            std::ostringstream filtered{};

            for (std::size_t i = 0U; i < diag_lines.size();) {
                auto header_line_number = parse_header_line_number(diag_lines[i], source_path);
                if (!header_line_number) {
                    ++i;
                    continue;
                }

                auto block_start = i;
                auto block_end = i + 1U;
                while (block_end < diag_lines.size()) {
                    if (parse_header_line_number(diag_lines[block_end], source_path)) {
                        break;
                    }
                    ++block_end;
                }

                bool keep = contains_token(diag_lines[block_start], symbol);
                if (!keep && *header_line_number > 0U && *header_line_number <= source_lines.size()) {
                    keep = contains_token(source_lines[*header_line_number - 1U], symbol);
                }
                if (!keep) {
                    for (const auto& range : symbol_ranges) {
                        if (*header_line_number >= range.first && *header_line_number <= range.second) {
                            keep = true;
                            break;
                        }
                    }
                }

                if (keep) {
                    for (auto line_index = block_start; line_index < block_end; ++line_index) {
                        filtered << diag_lines[line_index] << '\n';
                    }
                }

                i = block_end;
            }

            auto filtered_text = filtered.str();
            if (!filtered_text.empty()) {
                return filtered_text;
            }

            return "no diagnostics matched symbol '{}'\n"_format(symbol);
        }

        static std::optional<std::string> resolve_symbol_name(
                const analysis_request& request, std::string_view symbol) {
            auto symbols = try_collect_defined_symbols(request);
            if (!symbols) {
                return std::nullopt;
            }

            for (const auto& candidate : *symbols) {
                if (candidate.mangled == symbol || contains_token(candidate.mangled, symbol) ||
                    contains_token(candidate.demangled, symbol)) {
                    return candidate.mangled;
                }
            }

            return std::nullopt;
        }

        static std::string extract_ir_for_symbol(const std::string& ir_text, std::string_view mangled_symbol) {
            auto lines = split_lines(ir_text);
            std::ostringstream extracted{};
            bool in_function = false;
            int brace_depth = 0;
            auto symbol_tag = "@{}("_format(mangled_symbol);

            for (const auto& line : lines) {
                if (!in_function) {
                    if (contains_token(line, "define"sv) && contains_token(line, symbol_tag)) {
                        in_function = true;
                    }
                    else {
                        continue;
                    }
                }

                extracted << line << '\n';
                for (auto c : line) {
                    if (c == '{') {
                        ++brace_depth;
                    }
                    else if (c == '}') {
                        --brace_depth;
                    }
                }
                if (in_function && brace_depth <= 0 && contains_token(line, "}"sv)) {
                    break;
                }
            }

            return extracted.str();
        }

        static std::string extract_asm_for_symbol(const std::string& asm_text, std::string_view mangled_symbol) {
            auto lines = split_lines(asm_text);
            std::ostringstream extracted{};
            bool in_function = false;
            auto begin_tag = "# -- Begin function {}"_format(mangled_symbol);
            auto label_tag = "{}:"_format(mangled_symbol);
            auto size_tag = ".size\t{}"_format(mangled_symbol);
            auto size_tag_space = ".size {}"_format(mangled_symbol);

            for (const auto& line : lines) {
                if (!in_function) {
                    if (contains_token(line, begin_tag) || starts_with(line, label_tag)) {
                        in_function = true;
                    }
                    else {
                        continue;
                    }
                }

                extracted << line << '\n';
                if (contains_token(line, "# -- End function"sv) || contains_token(line, size_tag) ||
                    contains_token(line, size_tag_space)) {
                    break;
                }
            }

            return extracted.str();
        }

        static std::string prepare_mca_symbol_input(std::string_view extracted_asm, std::string_view asm_syntax) {
            auto prepared = std::string{};
            prepared.reserve(extracted_asm.size() + 64U);
            prepared.append(".text\n");
            if (asm_syntax == "intel"sv) {
                prepared.append(".intel_syntax noprefix\n");
            }
            auto lines = split_lines(std::string{extracted_asm});
            for (const auto& line : lines) {
                auto trimmed = trim_ascii(line);
                if (trimmed.starts_with(".cfi_"sv)) {
                    continue;
                }
                prepared.append(line);
                prepared.push_back('\n');
            }
            return prepared;
        }

    }  // namespace detail

    analysis_result run_analysis(const analysis_request& request, analysis_kind kind) {
        if (request.decl_cells.empty() && request.exec_cells.empty()) {
            throw std::runtime_error("analysis requires at least one stored cell");
        }

        auto artifacts_root = request.session_dir / "artifacts";
        auto inputs_dir = artifacts_root / "inputs";
        auto kind_dir = artifacts_root / std::string(to_string(kind));

        detail::ensure_dir(inputs_dir);
        detail::ensure_dir(kind_dir);

        auto id = detail::make_artifact_id(request, kind);
        auto source_path = inputs_dir / (id + ".cpp");

        auto extension = std::string{};
        switch (kind) {
            case analysis_kind::asm_text:
                extension = ".s";
                break;
            case analysis_kind::ir:
                extension = ".ll";
                break;
            case analysis_kind::diag:
            case analysis_kind::mca:
                extension = ".txt";
                break;
        }

        auto artifact_path = kind_dir / (id + extension);
        auto stdout_path = kind_dir / (id + ".stdout.txt");
        auto stderr_path = kind_dir / (id + ".stderr.txt");

        {
            std::ofstream out{source_path};
            if (!out) {
                throw std::runtime_error("failed to write source file: {}"_format(source_path.string()));
            }
            out << detail::render_source(request.decl_cells, request.exec_cells);
            if (!out) {
                throw std::runtime_error("failed to write source file: {}"_format(source_path.string()));
            }
        }

        analysis_result result{};
        result.kind = kind;
        result.source_path = source_path;
        result.artifact_path = artifact_path;
        result.stdout_path = stdout_path;
        result.stderr_path = stderr_path;

        if (kind == analysis_kind::mca) {
            auto asm_path = kind_dir / (id + ".input.s");
            auto compile_stdout_path = kind_dir / (id + ".compile.stdout.txt");
            auto compile_stderr_path = kind_dir / (id + ".compile.stderr.txt");

            auto compile_command = detail::build_command(request, analysis_kind::asm_text, source_path, asm_path);
            auto compile_exit = detail::run_process(compile_command, compile_stdout_path, compile_stderr_path);
            if (compile_exit != 0) {
                auto compile_stdout = detail::read_text_file(compile_stdout_path);
                auto compile_stderr = detail::read_text_file(compile_stderr_path);

                detail::write_text_file(stdout_path, compile_stdout);
                detail::write_text_file(stderr_path, compile_stderr);

                detail::write_text_file(artifact_path, compile_stdout);

                result.exit_code = compile_exit;
                result.success = false;
                result.command = std::move(compile_command);
                result.artifact_text = std::move(compile_stdout);
                result.diagnostics_text = std::move(compile_stderr);
                return result;
            }

            if (request.symbol) {
                auto resolved = detail::resolve_symbol_name(request, *request.symbol);
                if (!resolved) {
                    throw std::runtime_error("unable to resolve symbol: {}"_format(*request.symbol));
                }

                auto asm_text = detail::read_text_file(asm_path);
                auto extracted = detail::extract_asm_for_symbol(asm_text, *resolved);
                if (extracted.empty()) {
                    throw std::runtime_error("symbol not found in artifact: {}"_format(*resolved));
                }
                auto prepared_input = detail::prepare_mca_symbol_input(extracted, request.asm_syntax);
                detail::write_text_file(asm_path, prepared_input);
            }

            auto mca_exit = 127;
            auto stdout_text = std::string{};
            auto stderr_text = std::string{};
            auto mca_command = std::vector<std::string>{};
            auto attempted = std::vector<std::string>{};
            auto mca_candidates = detail::build_mca_executable_candidates(request, kind_dir, id);

            for (const auto& candidate : mca_candidates) {
                mca_command = detail::build_mca_command(request, asm_path, candidate);
                mca_exit = detail::run_process(mca_command, stdout_path, stderr_path);
                stdout_text = detail::read_text_file(stdout_path);
                stderr_text = detail::read_text_file(stderr_path);
                attempted.push_back(candidate);
                auto tool_missing = mca_exit == 127 && stdout_text.empty() && stderr_text.empty();
                if (!tool_missing) {
                    break;
                }
            }

            if (mca_exit == 127 && stdout_text.empty() && stderr_text.empty()) {
                if (attempted.empty()) {
                    stderr_text = "failed to execute llvm-mca tool: {}\n"_format(request.mca_path.string());
                }
                else {
                    stderr_text = "failed to execute llvm-mca tool: {}\ntried: {}\n"_format(
                            request.mca_path.string(), detail::join_with_separator(attempted, ", "sv));
                }
                detail::write_text_file(stderr_path, stderr_text);
            }

            detail::write_text_file(artifact_path, stdout_text);

            result.exit_code = mca_exit;
            result.success = (mca_exit == 0);
            result.command = std::move(mca_command);
            result.artifact_text = std::move(stdout_text);
            result.diagnostics_text = std::move(stderr_text);
            return result;
        }

        if (kind == analysis_kind::diag) {
            std::ofstream artifact{artifact_path};
            if (!artifact) {
                throw std::runtime_error("failed to open diagnostic artifact: {}"_format(artifact_path.string()));
            }
        }

        auto command = detail::build_command(request, kind, source_path, artifact_path);
        auto exit_code = detail::run_process(command, stdout_path, stderr_path);

        result.exit_code = exit_code;
        result.success = (exit_code == 0);
        result.command = command;

        if (kind == analysis_kind::diag) {
            auto stdout_text = detail::read_text_file(stdout_path);
            auto stderr_text = detail::read_text_file(stderr_path);
            {
                std::ofstream artifact_out{artifact_path};
                if (!artifact_out) {
                    throw std::runtime_error("failed to open diagnostic artifact: {}"_format(artifact_path.string()));
                }
                artifact_out << stderr_text;
                if (!stdout_text.empty()) {
                    if (!stderr_text.empty()) {
                        artifact_out << '\n';
                    }
                    artifact_out << stdout_text;
                }
            }
            result.diagnostics_text = detail::read_text_file(artifact_path);
            result.artifact_text = result.diagnostics_text;
            if (request.symbol) {
                auto source_text = detail::read_text_file(source_path);
                auto filtered = detail::filter_diag_by_symbol(
                        result.artifact_text, source_text, source_path.string(), *request.symbol);
                {
                    std::ofstream artifact_out{artifact_path};
                    if (!artifact_out) {
                        throw std::runtime_error(
                                "failed to open diagnostic artifact: {}"_format(artifact_path.string()));
                    }
                    artifact_out << filtered;
                }
                result.diagnostics_text = filtered;
                result.artifact_text = filtered;
            }
        }
        else {
            result.artifact_text = detail::read_text_file(artifact_path);
            result.diagnostics_text = detail::read_text_file(stderr_path);
            if (request.symbol) {
                auto resolved = detail::resolve_symbol_name(request, *request.symbol);
                if (!resolved) {
                    throw std::runtime_error("unable to resolve symbol: {}"_format(*request.symbol));
                }

                auto extracted = std::string{};
                if (kind == analysis_kind::asm_text) {
                    extracted = detail::extract_asm_for_symbol(result.artifact_text, *resolved);
                }
                else if (kind == analysis_kind::ir) {
                    extracted = detail::extract_ir_for_symbol(result.artifact_text, *resolved);
                }

                if (extracted.empty()) {
                    throw std::runtime_error("symbol not found in artifact: {}"_format(*resolved));
                }

                {
                    std::ofstream artifact_out{artifact_path};
                    if (!artifact_out) {
                        throw std::runtime_error(
                                "failed to open artifact for symbol extraction: {}"_format(artifact_path.string()));
                    }
                    artifact_out << extracted;
                }
                result.artifact_text = extracted;
            }
        }

        return result;
    }

    std::vector<analysis_symbol> list_symbols(const analysis_request& request) {
        if (request.decl_cells.empty() && request.exec_cells.empty()) {
            throw std::runtime_error("symbol listing requires at least one stored cell");
        }

        auto symbols = detail::try_collect_defined_symbols(request);
        if (!symbols) {
            throw std::runtime_error("failed to collect symbols from current snapshot");
        }
        return *symbols;
    }

    std::string synthesize_source(const analysis_request& request) {
        return detail::render_source(request.decl_cells, request.exec_cells);
    }

}  // namespace sontag
