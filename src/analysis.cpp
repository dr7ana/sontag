#include "sontag/analysis.hpp"

#include <cxxabi.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <unistd.h>

#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <functional>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <system_error>
#include <vector>

namespace fs = std::filesystem;

namespace sontag {
    namespace detail {

        using namespace std::string_view_literals;

        static std::string read_text_file(const fs::path& path) {
            std::ifstream in{path};
            if (!in) {
                return {};
            }
            std::ostringstream ss{};
            ss << in.rdbuf();
            return ss.str();
        }

        static std::string joined_cells(const std::vector<std::string>& cells) {
            std::ostringstream source{};
            source << "// generated by sontag m1\n";
            for (auto i = std::size_t{0}; i < cells.size(); ++i) {
                source << "// cell " << (i + 1U) << '\n';
                source << cells[i] << "\n\n";
            }
            return source.str();
        }

        static std::string make_artifact_id(const analysis_request& request, analysis_kind kind) {
            std::ostringstream key{};
            key << to_string(kind) << '\n';
            key << to_string(request.language_standard) << '\n';
            key << to_string(request.opt_level) << '\n';
            key << request.asm_syntax << '\n';
            if (request.symbol) {
                key << *request.symbol << '\n';
            }
            if (request.target_triple) {
                key << *request.target_triple << '\n';
            }
            if (request.cpu) {
                key << *request.cpu << '\n';
            }
            for (const auto& cell : request.cells) {
                key << cell << '\n';
            }

            auto hash_value = std::hash<std::string>{}(key.str());
            std::ostringstream id{};
            id << std::hex << hash_value;
            return id.str();
        }

        static void ensure_dir(const fs::path& path) {
            std::error_code ec{};
            fs::create_directories(path, ec);
            if (ec) {
                throw std::runtime_error("failed to create directory: " + path.string());
            }
        }

        static int open_write_file(const fs::path& path) {
            auto fd = ::open(path.c_str(), O_CREAT | O_WRONLY | O_TRUNC, 0644);
            if (fd < 0) {
                throw std::runtime_error("failed to open file for write: " + path.string());
            }
            return fd;
        }

        static int run_process(
                const std::vector<std::string>& args, const fs::path& stdout_path, const fs::path& stderr_path) {
            auto stdout_fd = open_write_file(stdout_path);
            auto stderr_fd = open_write_file(stderr_path);

            auto pid = ::fork();
            if (pid < 0) {
                ::close(stdout_fd);
                ::close(stderr_fd);
                throw std::runtime_error("fork failed");
            }

            if (pid == 0) {
                if (::dup2(stdout_fd, STDOUT_FILENO) < 0) {
                    _exit(127);
                }
                if (::dup2(stderr_fd, STDERR_FILENO) < 0) {
                    _exit(127);
                }

                ::close(stdout_fd);
                ::close(stderr_fd);

                std::vector<char*> argv{};
                argv.reserve(args.size() + 1U);
                for (const auto& arg : args) {
                    argv.push_back(const_cast<char*>(arg.c_str()));
                }
                argv.push_back(nullptr);

                ::execvp(argv[0], argv.data());
                _exit(127);
            }

            ::close(stdout_fd);
            ::close(stderr_fd);

            int status = 0;
            if (::waitpid(pid, &status, 0) < 0) {
                throw std::runtime_error("waitpid failed");
            }

            if (WIFEXITED(status)) {
                return WEXITSTATUS(status);
            }
            if (WIFSIGNALED(status)) {
                return 128 + WTERMSIG(status);
            }
            return 1;
        }

        static std::vector<std::string> base_clang_args(const analysis_request& request) {
            std::vector<std::string> args{};
            args.push_back(request.clang_path.string());
            auto std_arg = std::string{"-std="};
            std_arg.append(to_string(request.language_standard));
            args.push_back(std::move(std_arg));

            auto opt_arg = std::string{"-"};
            opt_arg.append(to_string(request.opt_level));
            args.push_back(std::move(opt_arg));

            if (request.target_triple) {
                auto target_arg = std::string{"--target="};
                target_arg.append(*request.target_triple);
                args.push_back(std::move(target_arg));
            }
            if (request.cpu) {
                auto cpu_arg = std::string{"-mcpu="};
                cpu_arg.append(*request.cpu);
                args.push_back(std::move(cpu_arg));
            }
            return args;
        }

        static std::vector<std::string> build_command(
                const analysis_request& request,
                analysis_kind kind,
                const fs::path& source_path,
                const fs::path& artifact_path) {
            auto args = base_clang_args(request);
            switch (kind) {
                case analysis_kind::asm_text:
                    args.push_back("-S");
                    args.push_back("-fverbose-asm");
                    if (request.asm_syntax == "intel") {
                        args.push_back("-masm=intel");
                    }
                    args.push_back(source_path.string());
                    args.push_back("-o");
                    args.push_back(artifact_path.string());
                    break;
                case analysis_kind::ir:
                    args.push_back("-S");
                    args.push_back("-emit-llvm");
                    args.push_back(source_path.string());
                    args.push_back("-o");
                    args.push_back(artifact_path.string());
                    break;
                case analysis_kind::diag:
                    args.push_back("-fsyntax-only");
                    args.push_back("-Wall");
                    args.push_back("-Wextra");
                    args.push_back(source_path.string());
                    break;
            }
            return args;
        }

        static bool starts_with(std::string_view value, std::string_view prefix) {
            return value.size() >= prefix.size() && value.substr(0U, prefix.size()) == prefix;
        }

        static std::vector<std::string> split_lines(const std::string& text) {
            std::vector<std::string> lines{};
            std::istringstream in{text};
            std::string line{};
            while (std::getline(in, line)) {
                lines.push_back(line);
            }
            return lines;
        }

        static bool contains_token(std::string_view haystack, std::string_view needle) {
            return haystack.find(needle) != std::string_view::npos;
        }

        static std::optional<std::size_t> parse_header_line_number(
                std::string_view line, const std::string& source_path) {
            if (!starts_with(line, source_path)) {
                return std::nullopt;
            }
            auto first_colon = line.find(':', source_path.size());
            if (first_colon == std::string_view::npos) {
                return std::nullopt;
            }
            auto second_colon = line.find(':', first_colon + 1U);
            if (second_colon == std::string_view::npos) {
                return std::nullopt;
            }
            auto line_number_text = line.substr(first_colon + 1U, second_colon - (first_colon + 1U));
            if (line_number_text.empty()) {
                return std::nullopt;
            }
            std::size_t line_number = 0U;
            for (auto c : line_number_text) {
                if (!std::isdigit(static_cast<unsigned char>(c))) {
                    return std::nullopt;
                }
                line_number = (line_number * 10U) + static_cast<std::size_t>(c - '0');
            }
            return line_number;
        }

        static std::string filter_diag_by_symbol(
                const std::string& diagnostics_text,
                const std::string& source_text,
                const std::string& source_path,
                std::string_view symbol) {
            if (diagnostics_text.empty()) {
                return {};
            }

            auto source_lines = split_lines(source_text);

            auto symbol_ranges = std::vector<std::pair<std::size_t, std::size_t>>{};
            for (std::size_t i = 0U; i < source_lines.size(); ++i) {
                if (!contains_token(source_lines[i], symbol) || !contains_token(source_lines[i], "("sv)) {
                    continue;
                }

                std::size_t j = i;
                bool found_open = false;
                int depth = 0;
                for (; j < source_lines.size(); ++j) {
                    for (auto c : source_lines[j]) {
                        if (c == '{') {
                            found_open = true;
                            ++depth;
                        }
                        else if (c == '}') {
                            --depth;
                        }
                    }
                    if (found_open && depth <= 0) {
                        symbol_ranges.push_back({i + 1U, j + 1U});
                        i = j;
                        break;
                    }
                }
            }
            auto diag_lines = split_lines(diagnostics_text);
            std::ostringstream filtered{};

            for (std::size_t i = 0U; i < diag_lines.size();) {
                auto header_line_number = parse_header_line_number(diag_lines[i], source_path);
                if (!header_line_number) {
                    ++i;
                    continue;
                }

                auto block_start = i;
                auto block_end = i + 1U;
                while (block_end < diag_lines.size()) {
                    if (parse_header_line_number(diag_lines[block_end], source_path)) {
                        break;
                    }
                    ++block_end;
                }

                bool keep = contains_token(diag_lines[block_start], symbol);
                if (!keep && *header_line_number > 0U && *header_line_number <= source_lines.size()) {
                    keep = contains_token(source_lines[*header_line_number - 1U], symbol);
                }
                if (!keep) {
                    for (const auto& range : symbol_ranges) {
                        if (*header_line_number >= range.first && *header_line_number <= range.second) {
                            keep = true;
                            break;
                        }
                    }
                }

                if (keep) {
                    for (auto line_index = block_start; line_index < block_end; ++line_index) {
                        filtered << diag_lines[line_index] << '\n';
                    }
                }

                i = block_end;
            }

            auto filtered_text = filtered.str();
            if (!filtered_text.empty()) {
                return filtered_text;
            }

            std::ostringstream no_match{};
            no_match << "no diagnostics matched symbol '" << symbol << "'\n";
            return no_match.str();
        }

        static std::optional<std::string> resolve_symbol_name(
                const analysis_request& request, std::string_view symbol) {
            auto source_path = request.session_dir / "artifacts" / "inputs" / "symbol_lookup.cpp";
            auto object_path = request.session_dir / "artifacts" / "inputs" / "symbol_lookup.o";
            auto stdout_path = request.session_dir / "artifacts" / "inputs" / "symbol_lookup.stdout.txt";
            auto stderr_path = request.session_dir / "artifacts" / "inputs" / "symbol_lookup.stderr.txt";

            ensure_dir(source_path.parent_path());

            {
                std::ofstream out{source_path};
                if (!out) {
                    throw std::runtime_error("failed to write source file: " + source_path.string());
                }
                out << joined_cells(request.cells);
                if (!out) {
                    throw std::runtime_error("failed to write source file: " + source_path.string());
                }
            }

            auto compile_args = base_clang_args(request);
            compile_args.push_back("-c");
            compile_args.push_back(source_path.string());
            compile_args.push_back("-o");
            compile_args.push_back(object_path.string());

            auto compile_exit = run_process(compile_args, stdout_path, stderr_path);
            if (compile_exit != 0) {
                return std::nullopt;
            }

            auto nm_stdout = request.session_dir / "artifacts" / "inputs" / "nm.stdout.txt";
            auto nm_stderr = request.session_dir / "artifacts" / "inputs" / "nm.stderr.txt";

            std::vector<std::string> nm_args{"nm", "--defined-only", object_path.string()};
            auto nm_exit = run_process(nm_args, nm_stdout, nm_stderr);
            if (nm_exit != 0) {
                return std::nullopt;
            }

            auto nm_text = read_text_file(nm_stdout);
            std::istringstream in{nm_text};
            std::string line{};
            while (std::getline(in, line)) {
                auto last_space = line.find_last_of(" \t");
                if (last_space == std::string::npos || last_space + 1U >= line.size()) {
                    continue;
                }
                auto candidate = line.substr(last_space + 1U);
                int status = 0;
                auto* demangled_ptr = abi::__cxa_demangle(candidate.c_str(), nullptr, nullptr, &status);
                auto demangled = std::string{};
                if (demangled_ptr != nullptr) {
                    demangled = demangled_ptr;
                    std::free(demangled_ptr);
                }

                if (candidate == symbol || contains_token(candidate, symbol) || contains_token(demangled, symbol)) {
                    return candidate;
                }
            }

            return std::nullopt;
        }

        static std::string extract_ir_for_symbol(const std::string& ir_text, std::string_view mangled_symbol) {
            auto lines = split_lines(ir_text);
            std::ostringstream extracted{};
            bool in_function = false;
            int brace_depth = 0;
            auto symbol_tag = std::string{"@"};
            symbol_tag.append(mangled_symbol);
            symbol_tag.append("(");

            for (const auto& line : lines) {
                if (!in_function) {
                    if (contains_token(line, "define"sv) && contains_token(line, symbol_tag)) {
                        in_function = true;
                    }
                    else {
                        continue;
                    }
                }

                extracted << line << '\n';
                for (auto c : line) {
                    if (c == '{') {
                        ++brace_depth;
                    }
                    else if (c == '}') {
                        --brace_depth;
                    }
                }
                if (in_function && brace_depth <= 0 && contains_token(line, "}"sv)) {
                    break;
                }
            }

            return extracted.str();
        }

        static std::string extract_asm_for_symbol(const std::string& asm_text, std::string_view mangled_symbol) {
            auto lines = split_lines(asm_text);
            std::ostringstream extracted{};
            bool in_function = false;
            auto begin_tag = std::string{"# -- Begin function "};
            begin_tag.append(mangled_symbol);
            auto label_tag = std::string{};
            label_tag.append(mangled_symbol);
            label_tag.append(":");
            auto size_tag = std::string{".size\t"};
            size_tag.append(mangled_symbol);
            auto size_tag_space = std::string{".size "};
            size_tag_space.append(mangled_symbol);

            for (const auto& line : lines) {
                if (!in_function) {
                    if (contains_token(line, begin_tag) || starts_with(line, label_tag)) {
                        in_function = true;
                    }
                    else {
                        continue;
                    }
                }

                extracted << line << '\n';
                if (contains_token(line, "# -- End function"sv) || contains_token(line, size_tag) ||
                    contains_token(line, size_tag_space)) {
                    break;
                }
            }

            return extracted.str();
        }

    }  // namespace detail

    analysis_result run_analysis(const analysis_request& request, analysis_kind kind) {
        if (request.cells.empty()) {
            throw std::runtime_error("analysis requires at least one stored cell");
        }

        auto artifacts_root = request.session_dir / "artifacts";
        auto inputs_dir = artifacts_root / "inputs";
        auto kind_dir = artifacts_root / std::string(to_string(kind));

        detail::ensure_dir(inputs_dir);
        detail::ensure_dir(kind_dir);

        auto id = detail::make_artifact_id(request, kind);
        auto source_path = inputs_dir / (id + ".cpp");

        auto extension = std::string{};
        switch (kind) {
            case analysis_kind::asm_text:
                extension = ".s";
                break;
            case analysis_kind::ir:
                extension = ".ll";
                break;
            case analysis_kind::diag:
                extension = ".txt";
                break;
        }

        auto artifact_path = kind_dir / (id + extension);
        auto stdout_path = kind_dir / (id + ".stdout.txt");
        auto stderr_path = kind_dir / (id + ".stderr.txt");

        {
            std::ofstream out{source_path};
            if (!out) {
                throw std::runtime_error("failed to write source file: " + source_path.string());
            }
            out << detail::joined_cells(request.cells);
            if (!out) {
                throw std::runtime_error("failed to write source file: " + source_path.string());
            }
        }

        if (kind == analysis_kind::diag) {
            std::ofstream artifact{artifact_path};
            if (!artifact) {
                throw std::runtime_error("failed to open diagnostic artifact: " + artifact_path.string());
            }
        }

        auto command = detail::build_command(request, kind, source_path, artifact_path);
        auto exit_code = detail::run_process(command, stdout_path, stderr_path);

        analysis_result result{};
        result.kind = kind;
        result.exit_code = exit_code;
        result.success = (exit_code == 0);
        result.source_path = source_path;
        result.artifact_path = artifact_path;
        result.stdout_path = stdout_path;
        result.stderr_path = stderr_path;
        result.command = command;

        if (kind == analysis_kind::diag) {
            auto stdout_text = detail::read_text_file(stdout_path);
            auto stderr_text = detail::read_text_file(stderr_path);
            {
                std::ofstream artifact_out{artifact_path};
                if (!artifact_out) {
                    throw std::runtime_error("failed to open diagnostic artifact: " + artifact_path.string());
                }
                artifact_out << stderr_text;
                if (!stdout_text.empty()) {
                    if (!stderr_text.empty()) {
                        artifact_out << '\n';
                    }
                    artifact_out << stdout_text;
                }
            }
            result.diagnostics_text = detail::read_text_file(artifact_path);
            result.artifact_text = result.diagnostics_text;
            if (request.symbol) {
                auto source_text = detail::read_text_file(source_path);
                auto filtered = detail::filter_diag_by_symbol(
                        result.artifact_text, source_text, source_path.string(), *request.symbol);
                {
                    std::ofstream artifact_out{artifact_path};
                    if (!artifact_out) {
                        throw std::runtime_error("failed to open diagnostic artifact: " + artifact_path.string());
                    }
                    artifact_out << filtered;
                }
                result.diagnostics_text = filtered;
                result.artifact_text = filtered;
            }
        }
        else {
            result.artifact_text = detail::read_text_file(artifact_path);
            result.diagnostics_text = detail::read_text_file(stderr_path);
            if (request.symbol) {
                auto resolved = detail::resolve_symbol_name(request, *request.symbol);
                if (!resolved) {
                    auto message = std::string{"unable to resolve symbol: "};
                    message.append(*request.symbol);
                    throw std::runtime_error(message);
                }

                auto extracted = std::string{};
                if (kind == analysis_kind::asm_text) {
                    extracted = detail::extract_asm_for_symbol(result.artifact_text, *resolved);
                }
                else if (kind == analysis_kind::ir) {
                    extracted = detail::extract_ir_for_symbol(result.artifact_text, *resolved);
                }

                if (extracted.empty()) {
                    auto message = std::string{"symbol not found in artifact: "};
                    message.append(*resolved);
                    throw std::runtime_error(message);
                }

                {
                    std::ofstream artifact_out{artifact_path};
                    if (!artifact_out) {
                        throw std::runtime_error(
                                "failed to open artifact for symbol extraction: " + artifact_path.string());
                    }
                    artifact_out << extracted;
                }
                result.artifact_text = extracted;
            }
        }

        return result;
    }

}  // namespace sontag
