#pragma once

#include <flat_map>
#include <string>

namespace sontag::tables {
    inline const std::flat_map<std::string, std::string> ARM{
            {"ABS", "Absolute value"},
            {"ADC", "Add with carry"},
            {"ADCLB", "Add with carry long"},
            {"ADCLT", "Add with carry long"},
            {"ADCS", "Add with carry, setting flags"},
            {"ADD", "Add"},
            {"ADDG", "Add with tag"},
            {"ADDHA", "Add horizontally vector elements to ZA tile"},
            {"ADDHN", "Add returning high narrow"},
            {"ADDHN2", "Add returning high narrow"},
            {"ADDHNB", "Add narrow high part"},
            {"ADDHNT", "Add narrow high part"},
            {"ADDP", "Add pairwise"},
            {"ADDPL", "Add multiple of predicate register size to scalar register"},
            {"ADDPT", "Add checked pointer"},
            {"ADDQP", "Add pairwise within quadword vector segments"},
            {"ADDQV", "Add reduction of quadword vector segments"},
            {"ADDS", "Add immediate value, setting flags"},
            {"ADDSPL", "Add multiple of Streaming SVE predicate register size to scalar register"},
            {"ADDSUBP", "Add subtract pairwise"},
            {"ADDSVL", "Add multiple of Streaming SVE vector register size to scalar register"},
            {"ADDV", "Add across vector"},
            {"ADDVA", "Add vertically vector elements to ZA tile"},
            {"ADDVL", "Add multiple of vector register size to scalar register"},
            {"ADR", "Calculate vector address"},
            {"ADRP", "Form PC-relative address to 4KB page"},
            {"AESD", "AES single round decryption"},
            {"AESDIMC", "Multi-vector AES single round decryption and inverse mix columns"},
            {"AESE", "AES single round encryption"},
            {"AESEMC", "Multi-vector AES single round encryption and mix columns"},
            {"AESIMC", "AES inverse mix columns"},
            {"AESMC", "AES mix columns"},
            {"AND", "Bitwise AND"},
            {"ANDQV", "Bitwise AND reduction of quadword vector segments"},
            {"ANDS", "Bitwise AND predicates, setting the condition flags"},
            {"ANDV", "Bitwise AND reduction to scalar"},
            {"ASR", "Arithmetic shift right by vector"},
            {"ASRD", "Arithmetic shift right for divide by immediate"},
            {"ASRR", "Reversed arithmetic shift right by vector"},
            {"ASRV", "Arithmetic shift right variable"},
            {"AUTDA", "Authenticate data address, using key A"},
            {"AUTDZA", "Authenticate data address, using key A"},
            {"AUTDB", "Authenticate data address, using key B"},
            {"AUTDZB", "Authenticate data address, using key B"},
            {"AUTIA", "Authenticate instruction address, using key A"},
            {"AUTIA1716", "Authenticate instruction address, using key A"},
            {"AUTIASP", "Authenticate instruction address, using key A"},
            {"AUTIAZ", "Authenticate instruction address, using key A"},
            {"AUTIZA", "Authenticate instruction address, using key A"},
            {"AUTIA171615", "Authenticate instruction address, using key A"},
            {"AUTIASPPC", "Authenticate return address using key A, using an immediate offset"},
            {"AUTIASPPCR", "Authenticate return address using key A, using a register"},
            {"AUTIB", "Authenticate instruction address, using key B"},
            {"AUTIB1716", "Authenticate instruction address, using key B"},
            {"AUTIBSP", "Authenticate instruction address, using key B"},
            {"AUTIBZ", "Authenticate instruction address, using key B"},
            {"AUTIZB", "Authenticate instruction address, using key B"},
            {"AUTIB171615", "Authenticate instruction address, using key B"},
            {"AUTIBSPPC", "Authenticate return address using key B, using an immediate offset"},
            {"AUTIBSPPCR", "Authenticate return address using key B, using a register"},
            {"AXFLAG", "Convert floating-point condition flags from Arm to external format"},
            {"B", "Branch"},
            {"B.cond", "Branch conditionally"},
            {"BC.cond", "Branch consistent conditionally"},
            {"BCAX", "Bitwise clear and exclusive-OR"},
            {"BDEP", "Scatter lower bits into positions selected by bitmask"},
            {"BEXT", "Gather lower bits from positions selected by bitmask"},
            {"BF1CVT", "8-bit floating-point convert to BFloat16"},
            {"BF2CVT", "Multi-vector 8-bit floating-point convert to BFloat16"},
            {"BF1CVTL", "8-bit floating-point convert to BFloat16"},
            {"BF1CVTL2", "8-bit floating-point convert to BFloat16"},
            {"BF2CVTL", "8-bit floating-point convert to BFloat16"},
            {"BF2CVTL2", "8-bit floating-point convert to BFloat16"},
            {"BF1CVTLT", "8-bit floating-point convert to BFloat16"},
            {"BF2CVTLT", "8-bit floating-point convert to BFloat16"},
            {"BFADD", "BFloat16 add"},
            {"BFCLAMP", "BFloat16 clamp to minimum/maximum number"},
            {"BFCVT", "Single-precision convert to BFloat16"},
            {"BFCVTN", "Single-precision convert to BFloat16"},
            {"BFCVTN2", "Single-precision convert to BFloat16"},
            {"BFCVTNT", "Single-precision convert to BFloat16"},
            {"BFDOT", "BFloat16 dot product to single-precision"},
            {"BFM", "Bitfield move"},
            {"BFMAX", "BFloat16 maximum"},
            {"BFMAXNM", "BFloat16 maximum number"},
            {"BFMIN", "BFloat16 minimum"},
            {"BFMINNM", "BFloat16 minimum number"},
            {"BFMLA", "BFloat16 fused multiply-add"},
            {"BFMLAL", "Multi-vector BFloat16 multiply-add to single-precision"},
            {"BFMLALB", "BFloat16 multiply-add to single-precision"},
            {"BFMLALT", "BFloat16 multiply-add to single-precision"},
            {"BFMLS", "BFloat16 fused multiply-subtract"},
            {"BFMLSL", "Multi-vector BFloat16 multiply-subtract from single-precision"},
            {"BFMLSLB", "BFloat16 multiply-subtract from single-precision"},
            {"BFMLSLT", "BFloat16 multiply-subtract from single-precision"},
            {"BFMMLA", "BFloat16 matrix multiply-accumulate"},
            {"BFMOP4A", "BFloat16 quarter-tile outer product, accumulating"},
            {"BFMOP4S", "BFloat16 quarter-tile outer product, subtracting"},
            {"BFMOPA", "BFloat16 outer product, accumulating"},
            {"BFMOPS", "BFloat16 outer product, subtracting"},
            {"BFMUL", "BFloat16 multiply"},
            {"BFSCALE", "BFloat16 adjust exponent"},
            {"BFSUB", "BFloat16 subtract"},
            {"BFTMOPA", "BFloat16 sparse outer product, accumulating"},
            {"BFVDOT", "Multi-vector BFloat16 vertical dot product by indexed element to single-precision"},
            {"BGRP", "Group bits to right or left as selected by bitmask"},
            {"BIC", "Bitwise clear"},
            {"BICS", "Bitwise bit clear, setting flags"},
            {"BIF", "Bitwise insert if false"},
            {"BIT", "Bitwise insert if true"},
            {"BL", "Branch with link"},
            {"BLR", "Branch with link to register"},
            {"BLRAA", "Branch with link to register, with pointer authentication"},
            {"BLRAAZ", "Branch with link to register, with pointer authentication"},
            {"BLRAB", "Branch with link to register, with pointer authentication"},
            {"BLRABZ", "Branch with link to register, with pointer authentication"},
            {"BMOPA", "Bitwise exclusive NOR population count outer product, accumulating"},
            {"BMOPS", "Bitwise exclusive NOR population count outer product, subtracting"},
            {"BR", "Branch to register"},
            {"BRAA", "Branch to register, with pointer authentication"},
            {"BRAAZ", "Branch to register, with pointer authentication"},
            {"BRAB", "Branch to register, with pointer authentication"},
            {"BRABZ", "Branch to register, with pointer authentication"},
            {"BRK", "Breakpoint instruction"},
            {"BRKA", "Break after first true condition"},
            {"BRKAS", "Break after first true condition, setting the condition flags"},
            {"BRKB", "Break before first true condition"},
            {"BRKBS", "Break before first true condition, setting the condition flags"},
            {"BRKN", "Propagate break to next partition"},
            {"BRKNS", "Propagate break to next partition, setting the condition flags"},
            {"BRKPA", "Break after first true condition, propagating from previous partition"},
            {"BRKPAS",
             "Break after first true condition, propagating from previous partition and setting the condition flags"},
            {"BRKPB", "Break before first true condition, propagating from previous partition"},
            {"BRKPBS",
             "Break before first true condition, propagating from previous partition and setting the condition flags"},
            {"BSL", "Bitwise select"},
            {"BSL1N", "Bitwise select with first input inverted"},
            {"BSL2N", "Bitwise select with second input inverted"},
            {"BTI", "Branch target identification"},
            {"CADD", "Complex integer add"},
            {"CAS", "Compare and swap word or doubleword in memory"},
            {"CASA", "Compare and swap word or doubleword in memory"},
            {"CASAL", "Compare and swap word or doubleword in memory"},
            {"CASL", "Compare and swap word or doubleword in memory"},
            {"CASB", "Compare and swap byte in memory"},
            {"CASAB", "Compare and swap byte in memory"},
            {"CASALB", "Compare and swap byte in memory"},
            {"CASLB", "Compare and swap byte in memory"},
            {"CASH", "Compare and swap halfword in memory"},
            {"CASAH", "Compare and swap halfword in memory"},
            {"CASALH", "Compare and swap halfword in memory"},
            {"CASLH", "Compare and swap halfword in memory"},
            {"CASP", "Compare and swap pair of words or doublewords in memory"},
            {"CASPA", "Compare and swap pair of words or doublewords in memory"},
            {"CASPAL", "Compare and swap pair of words or doublewords in memory"},
            {"CASPL", "Compare and swap pair of words or doublewords in memory"},
            {"CASPT", "Compare and swap pair unprivileged"},
            {"CASPAT", "Compare and swap pair unprivileged"},
            {"CASPALT", "Compare and swap pair unprivileged"},
            {"CASPLT", "Compare and swap pair unprivileged"},
            {"CAST", "Compare and swap unprivileged"},
            {"CASAT", "Compare and swap unprivileged"},
            {"CASALT", "Compare and swap unprivileged"},
            {"CASLT", "Compare and swap unprivileged"},
            {"CB<cc>", "Compare registers and branch"},
            {"CBB<cc>", "Compare bytes and branch"},
            {"CBH<cc>", "Compare halfwords and branch"},
            {"CBNZ", "Compare and branch on nonzero"},
            {"CBZ", "Compare and branch on zero"},
            {"CCMN", "Conditional compare negative"},
            {"CCMP", "Conditional compare"},
            {"CDOT", "Complex integer dot product"},
            {"CFINV", "Invert carry flag"},
            {"CHKFEAT", "Check feature status"},
            {"CLASTA", "Conditionally extract element after last to vector register"},
            {"CLASTB", "Conditionally extract last element to vector register"},
            {"CLRBHB", "Clear branch history"},
            {"CLREX", "Clear exclusive"},
            {"CLS", "Count leading sign bits"},
            {"CLZ", "Count leading zeros"},
            {"CMEQ", "Compare bitwise equal"},
            {"CMGE", "Compare signed greater than or equal"},
            {"CMGT", "Compare signed greater than"},
            {"CMHI", "Compare unsigned higher"},
            {"CMHS", "Compare unsigned higher or same"},
            {"CMLA", "Complex integer multiply-add"},
            {"CMLE", "Compare signed less than or equal to zero"},
            {"CMLT", "Compare signed less than zero"},
            {"CMP<cc>", "Compare vectors"},
            {"CMTST", "Compare bitwise test bits nonzero"},
            {"CNOT", "Logically invert boolean condition"},
            {"CNT", "Count bits"},
            {"CNTB", "Set scalar to multiple of predicate constraint element count"},
            {"CNTD", "Set scalar to multiple of predicate constraint element count"},
            {"CNTH", "Set scalar to multiple of predicate constraint element count"},
            {"CNTW", "Set scalar to multiple of predicate constraint element count"},
            {"CNTP", "Set scalar to count from predicate-as-counter"},
            {"COMPACT", "Copy Active vector elements to lower-numbered elements"},
            {"CPY", "Copy SIMD&FP scalar register to vector elements"},
            {"CPYFP", "Memory copy forward-only"},
            {"CPYFM", "Memory copy forward-only"},
            {"CPYFE", "Memory copy forward-only"},
            {"CPYFPN", "Memory copy forward-only, reads and writes non-temporal"},
            {"CPYFMN", "Memory copy forward-only, reads and writes non-temporal"},
            {"CPYFEN", "Memory copy forward-only, reads and writes non-temporal"},
            {"CPYFPRN", "Memory copy forward-only, reads non-temporal"},
            {"CPYFMRN", "Memory copy forward-only, reads non-temporal"},
            {"CPYFERN", "Memory copy forward-only, reads non-temporal"},
            {"CPYFPRT", "Memory copy forward-only, reads unprivileged"},
            {"CPYFMRT", "Memory copy forward-only, reads unprivileged"},
            {"CPYFERT", "Memory copy forward-only, reads unprivileged"},
            {"CPYFPRTN", "Memory copy forward-only, reads unprivileged, reads and writes non-temporal"},
            {"CPYFMRTN", "Memory copy forward-only, reads unprivileged, reads and writes non-temporal"},
            {"CPYFERTN", "Memory copy forward-only, reads unprivileged, reads and writes non-temporal"},
            {"CPYFPRTRN", "Memory copy forward-only, reads unprivileged and non-temporal"},
            {"CPYFMRTRN", "Memory copy forward-only, reads unprivileged and non-temporal"},
            {"CPYFERTRN", "Memory copy forward-only, reads unprivileged and non-temporal"},
            {"CPYFPRTWN", "Memory copy forward-only, reads unprivileged, writes non-temporal"},
            {"CPYFMRTWN", "Memory copy forward-only, reads unprivileged, writes non-temporal"},
            {"CPYFERTWN", "Memory copy forward-only, reads unprivileged, writes non-temporal"},
            {"CPYFPT", "Memory copy forward-only, reads and writes unprivileged"},
            {"CPYFMT", "Memory copy forward-only, reads and writes unprivileged"},
            {"CPYFET", "Memory copy forward-only, reads and writes unprivileged"},
            {"CPYFPTN", "Memory copy forward-only, reads and writes unprivileged and non-temporal"},
            {"CPYFMTN", "Memory copy forward-only, reads and writes unprivileged and non-temporal"},
            {"CPYFETN", "Memory copy forward-only, reads and writes unprivileged and non-temporal"},
            {"CPYFPTRN", "Memory copy forward-only, reads and writes unprivileged, reads non-temporal"},
            {"CPYFMTRN", "Memory copy forward-only, reads and writes unprivileged, reads non-temporal"},
            {"CPYFETRN", "Memory copy forward-only, reads and writes unprivileged, reads non-temporal"},
            {"CPYFPTWN", "Memory copy forward-only, reads and writes unprivileged, writes non-temporal"},
            {"CPYFMTWN", "Memory copy forward-only, reads and writes unprivileged, writes non-temporal"},
            {"CPYFETWN", "Memory copy forward-only, reads and writes unprivileged, writes non-temporal"},
            {"CPYFPWN", "Memory copy forward-only, writes non-temporal"},
            {"CPYFMWN", "Memory copy forward-only, writes non-temporal"},
            {"CPYFEWN", "Memory copy forward-only, writes non-temporal"},
            {"CPYFPWT", "Memory copy forward-only, writes unprivileged"},
            {"CPYFMWT", "Memory copy forward-only, writes unprivileged"},
            {"CPYFEWT", "Memory copy forward-only, writes unprivileged"},
            {"CPYFPWTN", "Memory copy forward-only, writes unprivileged, reads and writes non-temporal"},
            {"CPYFMWTN", "Memory copy forward-only, writes unprivileged, reads and writes non-temporal"},
            {"CPYFEWTN", "Memory copy forward-only, writes unprivileged, reads and writes non-temporal"},
            {"CPYFPWTRN", "Memory copy forward-only, writes unprivileged, reads non-temporal"},
            {"CPYFMWTRN", "Memory copy forward-only, writes unprivileged, reads non-temporal"},
            {"CPYFEWTRN", "Memory copy forward-only, writes unprivileged, reads non-temporal"},
            {"CPYFPWTWN", "Memory copy forward-only, writes unprivileged and non-temporal"},
            {"CPYFMWTWN", "Memory copy forward-only, writes unprivileged and non-temporal"},
            {"CPYFEWTWN", "Memory copy forward-only, writes unprivileged and non-temporal"},
            {"CPYP", "Memory copy"},
            {"CPYM", "Memory copy"},
            {"CPYE", "Memory copy"},
            {"CPYPN", "Memory copy, reads and writes non-temporal"},
            {"CPYMN", "Memory copy, reads and writes non-temporal"},
            {"CPYEN", "Memory copy, reads and writes non-temporal"},
            {"CPYPRN", "Memory copy, reads non-temporal"},
            {"CPYMRN", "Memory copy, reads non-temporal"},
            {"CPYERN", "Memory copy, reads non-temporal"},
            {"CPYPRT", "Memory copy, reads unprivileged"},
            {"CPYMRT", "Memory copy, reads unprivileged"},
            {"CPYERT", "Memory copy, reads unprivileged"},
            {"CPYPRTN", "Memory copy, reads unprivileged, reads and writes non-temporal"},
            {"CPYMRTN", "Memory copy, reads unprivileged, reads and writes non-temporal"},
            {"CPYERTN", "Memory copy, reads unprivileged, reads and writes non-temporal"},
            {"CPYPRTRN", "Memory copy, reads unprivileged and non-temporal"},
            {"CPYMRTRN", "Memory copy, reads unprivileged and non-temporal"},
            {"CPYERTRN", "Memory copy, reads unprivileged and non-temporal"},
            {"CPYPRTWN", "Memory copy, reads unprivileged, writes non-temporal"},
            {"CPYMRTWN", "Memory copy, reads unprivileged, writes non-temporal"},
            {"CPYERTWN", "Memory copy, reads unprivileged, writes non-temporal"},
            {"CPYPT", "Memory copy, reads and writes unprivileged"},
            {"CPYMT", "Memory copy, reads and writes unprivileged"},
            {"CPYET", "Memory copy, reads and writes unprivileged"},
            {"CPYPTN", "Memory copy, reads and writes unprivileged and non-temporal"},
            {"CPYMTN", "Memory copy, reads and writes unprivileged and non-temporal"},
            {"CPYETN", "Memory copy, reads and writes unprivileged and non-temporal"},
            {"CPYPTRN", "Memory copy, reads and writes unprivileged, reads non-temporal"},
            {"CPYMTRN", "Memory copy, reads and writes unprivileged, reads non-temporal"},
            {"CPYETRN", "Memory copy, reads and writes unprivileged, reads non-temporal"},
            {"CPYPTWN", "Memory copy, reads and writes unprivileged, writes non-temporal"},
            {"CPYMTWN", "Memory copy, reads and writes unprivileged, writes non-temporal"},
            {"CPYETWN", "Memory copy, reads and writes unprivileged, writes non-temporal"},
            {"CPYPWN", "Memory copy, writes non-temporal"},
            {"CPYMWN", "Memory copy, writes non-temporal"},
            {"CPYEWN", "Memory copy, writes non-temporal"},
            {"CPYPWT", "Memory copy, writes unprivileged"},
            {"CPYMWT", "Memory copy, writes unprivileged"},
            {"CPYEWT", "Memory copy, writes unprivileged"},
            {"CPYPWTN", "Memory copy, writes unprivileged, reads and writes non-temporal"},
            {"CPYMWTN", "Memory copy, writes unprivileged, reads and writes non-temporal"},
            {"CPYEWTN", "Memory copy, writes unprivileged, reads and writes non-temporal"},
            {"CPYPWTRN", "Memory copy, writes unprivileged, reads non-temporal"},
            {"CPYMWTRN", "Memory copy, writes unprivileged, reads non-temporal"},
            {"CPYEWTRN", "Memory copy, writes unprivileged, reads non-temporal"},
            {"CPYPWTWN", "Memory copy, writes unprivileged and non-temporal"},
            {"CPYMWTWN", "Memory copy, writes unprivileged and non-temporal"},
            {"CPYEWTWN", "Memory copy, writes unprivileged and non-temporal"},
            {"CRC32B", "CRC32 checksum"},
            {"CRC32H", "CRC32 checksum"},
            {"CRC32W", "CRC32 checksum"},
            {"CRC32X", "CRC32 checksum"},
            {"CRC32CB", "CRC32C checksum"},
            {"CRC32CH", "CRC32C checksum"},
            {"CRC32CW", "CRC32C checksum"},
            {"CRC32CX", "CRC32C checksum"},
            {"CSDB", "Consumption of speculative data barrier"},
            {"CSEL", "Conditional select"},
            {"CSINC", "Conditional select increment"},
            {"CSINV", "Conditional select invert"},
            {"CSNEG", "Conditional select negation"},
            {"CTERMEQ", "Compare and terminate loop"},
            {"CTERMNE", "Compare and terminate loop"},
            {"CTZ", "Count trailing zeros"},
            {"DCPS1", "Debug change PE state to EL1"},
            {"DCPS2", "Debug change PE state to EL2"},
            {"DCPS3", "Debug change PE state to EL3"},
            {"DECB", "Decrement scalar by multiple of predicate constraint element count"},
            {"DECD", "Decrement scalar by multiple of predicate constraint element count"},
            {"DECH", "Decrement scalar by multiple of predicate constraint element count"},
            {"DECW", "Decrement scalar by multiple of predicate constraint element count"},
            {"DECP", "Decrement scalar by count of true predicate elements"},
            {"DGH", "Data gathering hint"},
            {"DMB", "Data memory barrier"},
            {"DRPS", "Debug restore PE state"},
            {"DSB", "Data synchronization barrier"},
            {"DUP", "Broadcast indexed element to vector"},
            {"DUPM", "Broadcast logical bitmask immediate to vector"},
            {"DUPQ", "Broadcast indexed element within each quadword vector segment"},
            {"EON", "Bitwise exclusive-OR NOT"},
            {"EOR", "Bitwise exclusive-OR"},
            {"EOR3", "Three-way bitwise exclusive-OR"},
            {"EORBT", "Interleaving exclusive-OR"},
            {"EORQV", "Bitwise exclusive-OR reduction of quadword vector segments"},
            {"EORS", "Bitwise exclusive-OR predicates, setting the condition flags"},
            {"EORTB", "Interleaving exclusive-OR"},
            {"EORV", "Bitwise exclusive-OR reduction to scalar"},
            {"ERET", "Exception return"},
            {"ERETAA", "Exception return, with pointer authentication"},
            {"ERETAB", "Exception return, with pointer authentication"},
            {"ESB", "Error synchronization barrier"},
            {"EXPAND", "Copy lower-numbered vector elements to Active elements"},
            {"EXT", "Extract vector from pair of vectors"},
            {"EXTQ", "Extract vector segment from each pair of quadword vector segments"},
            {"EXTR", "Extract register"},
            {"F1CVT", "8-bit floating-point convert to half-precision"},
            {"F2CVT", "Multi-vector 8-bit floating-point convert to half-precision"},
            {"F2CVTL2", "8-bit floating-point convert to half-precision"},
            {"F1CVTL", "8-bit floating-point convert to half-precision"},
            {"F2CVTL", "Multi-vector 8-bit floating-point convert to deinterleaved half-precision"},
            {"F1CVTLT", "8-bit floating-point convert to half-precision"},
            {"FABD", "Floating-point absolute difference"},
            {"FABS", "Floating-point absolute value"},
            {"FAC<cc>", "Floating-point absolute compare"},
            {"FACGE", "Floating-point absolute compare greater than or equal"},
            {"FACGT", "Floating-point absolute compare greater than"},
            {"FADD", "Floating-point add"},
            {"FADDA", "Floating-point add strictly-ordered reduction, accumulating in scalar"},
            {"FADDP", "Floating-point add pairwise"},
            {"FADDQV", "Floating-point add recursive reduction of quadword vector segments"},
            {"FADDV", "Floating-point add recursive reduction to scalar"},
            {"FAMAX", "Floating-point absolute maximum"},
            {"FAMIN", "Floating-point absolute minimum"},
            {"FCADD", "Floating-point complex add"},
            {"FCCMP", "Floating-point conditional quiet compare"},
            {"FCCMPE", "Floating-point conditional signaling compare"},
            {"FCLAMP", "Floating-point clamp to minimum/maximum number"},
            {"FCM<cc>", "Floating-point compare"},
            {"FCMEQ", "Floating-point compare equal"},
            {"FCMGE", "Floating-point compare greater than or equal"},
            {"FCMGT", "Floating-point compare greater than"},
            {"FCMLA", "Floating-point complex multiply-add"},
            {"FCMLE", "Floating-point compare less than or equal to zero"},
            {"FCMLT", "Floating-point compare less than zero"},
            {"FCMP", "Floating-point quiet compare"},
            {"FCMPE", "Floating-point signaling compare"},
            {"FCPY", "Copy floating-point immediate to vector elements"},
            {"FCSEL", "Floating-point conditional select"},
            {"FCVT", "Floating-point convert"},
            {"FCVTAS", "Floating-point convert to signed integer, rounding to nearest with ties to away"},
            {"FCVTAU", "Floating-point convert to unsigned integer, rounding to nearest with ties to away"},
            {"FCVTL", "Floating-point convert to higher precision long"},
            {"FCVTL2", "Floating-point convert to higher precision long"},
            {"FCVTLT", "Floating-point widening convert"},
            {"FCVTMS", "Floating-point convert to signed integer, rounding toward minus infinity"},
            {"FCVTMU", "Floating-point convert to unsigned integer, rounding toward minus infinity"},
            {"FCVTN", "Half-precision convert to 8-bit floating-point"},
            {"FCVTN2", "Floating-point convert to lower precision narrow"},
            {"FCVTNB", "Single-precision convert to interleaved 8-bit floating-point"},
            {"FCVTNS", "Floating-point convert to signed integer, rounding to nearest with ties to even"},
            {"FCVTNT", "Floating-point narrowing convert"},
            {"FCVTNU", "Floating-point convert to unsigned integer, rounding to nearest with ties to even"},
            {"FCVTPS", "Floating-point convert to signed integer, rounding toward plus infinity"},
            {"FCVTPU", "Floating-point convert to unsigned integer, rounding toward plus infinity"},
            {"FCVTX", "Double-precision convert to single-precision, rounding to odd"},
            {"FCVTXN", "Floating-point convert to lower precision narrow, rounding to odd"},
            {"FCVTXN2", "Floating-point convert to lower precision narrow, rounding to odd"},
            {"FCVTXNT", "Double-precision convert to single-precision, rounding to odd"},
            {"FCVTZS", "Floating-point convert to signed integer, rounding toward zero"},
            {"FCVTZSN", "Floating-point narrowing convert to interleaved signed integer, rounding toward zero"},
            {"FCVTZU", "Floating-point convert to unsigned integer, rounding toward zero"},
            {"FCVTZUN", "Floating-point narrowing convert to interleaved unsigned integer, rounding toward zero"},
            {"FDIV", "Floating-point divide"},
            {"FDIVR", "Floating-point reversed divide"},
            {"FDOT", "Half-precision dot product to single-precision"},
            {"FDUP", "Broadcast floating-point immediate to vector elements"},
            {"FEXPA", "Floating-point exponential accelerator"},
            {"FIRSTP", "Scalar index of first true predicate element"},
            {"FJCVTZS", "Floating-point Javascript convert to signed fixed-point, rounding toward zero"},
            {"FLOGB", "Floating-point base 2 logarithm as integer"},
            {"FMAD", "Floating-point fused multiply-add to multiplicand"},
            {"FMADD", "Floating-point fused multiply-add"},
            {"FMAX", "Floating-point maximum"},
            {"FMAXNM", "Floating-point maximum number"},
            {"FMAXNMP", "Floating-point maximum number pairwise"},
            {"FMAXNMQV", "Floating-point maximum number recursive reduction of quadword vector segments"},
            {"FMAXNMV", "Floating-point maximum number recursive reduction to scalar"},
            {"FMAXP", "Floating-point maximum pairwise"},
            {"FMAXQV", "Floating-point maximum reduction of quadword vector segments"},
            {"FMAXV", "Floating-point maximum recursive reduction to scalar"},
            {"FMIN", "Floating-point minimum"},
            {"FMINNM", "Floating-point minimum number"},
            {"FMINNMP", "Floating-point minimum number pairwise"},
            {"FMINNMQV", "Floating-point minimum number recursive reduction of quadword vector segments"},
            {"FMINNMV", "Floating-point minimum number recursive reduction to scalar"},
            {"FMINP", "Floating-point minimum pairwise"},
            {"FMINQV", "Floating-point minimum recursive reduction of quadword vector segments"},
            {"FMINV", "Floating-point minimum recursive reduction to scalar"},
            {"FMLA", "Floating-point fused multiply-add"},
            {"FMLAL", "Floating-point fused multiply-add long to accumulator"},
            {"FMLAL2", "Floating-point fused multiply-add long to accumulator"},
            {"FMLALB", "Half-precision multiply-add to single-precision"},
            {"FMLALT", "Half-precision multiply-add to single-precision"},
            {"FMLALL", "Multi-vector 8-bit floating-point multiply-add to single-precision"},
            {"FMLALLBB", "8-bit floating-point multiply-add to single-precision"},
            {"FMLALLBT", "8-bit floating-point multiply-add to single-precision"},
            {"FMLALLTB", "8-bit floating-point multiply-add to single-precision"},
            {"FMLALLTT", "8-bit floating-point multiply-add to single-precision"},
            {"FMLS", "Floating-point fused multiply-subtract"},
            {"FMLSL", "Floating-point fused multiply-subtract long from accumulator"},
            {"FMLSL2", "Floating-point fused multiply-subtract long from accumulator"},
            {"FMLSLB", "Half-precision multiply-subtract from single-precision"},
            {"FMLSLT", "Half-precision multiply-subtract from single-precision"},
            {"FMMLA", "Floating-point/Half-precision matrix multiply-accumulate"},
            {"FMOP4A", "Floating-point quarter-tile outer product, accumulating"},
            {"FMOP4S", "Floating-point quarter-tile outer product, subtracting"},
            {"FMOPA", "Floating-point outer product, accumulating"},
            {"FMOPS", "Floating-point outer product, subtracting"},
            {"FMOV", "Floating-point move immediate"},
            {"FMSB", "Floating-point fused multiply-subtract to multiplicand"},
            {"FMSUB", "Floating-point fused multiply-subtract"},
            {"FMUL", "Floating-point multiply"},
            {"FMULX", "Floating-point multiply extended"},
            {"FNEG", "Floating-point negate"},
            {"FNMAD", "Floating-point negated fused multiply-add to multiplicand"},
            {"FNMADD", "Floating-point negated fused multiply-add"},
            {"FNMLA", "Floating-point negated fused multiply-add"},
            {"FNMLS", "Floating-point negated fused multiply-subtract"},
            {"FNMSB", "Floating-point negated fused multiply-subtract to multiplicand"},
            {"FNMSUB", "Floating-point negated fused multiply-subtract"},
            {"FNMUL", "Floating-point multiply-negate"},
            {"FRECPE", "Floating-point reciprocal estimate"},
            {"FRECPS", "Floating-point reciprocal step"},
            {"FRECPX", "Floating-point reciprocal exponent"},
            {"FRINT<r>", "Floating-point round to integral value"},
            {"FRINT32X", "Floating-point round to 32-bit integer"},
            {"FRINT32Z", "Floating-point round to 32-bit integer toward zero"},
            {"FRINT64X", "Floating-point round to 64-bit integer"},
            {"FRINT64Z", "Floating-point round to 64-bit integer toward zero"},
            {"FRINTA", "Floating-point round to integral, to nearest with ties to away"},
            {"FRINTI", "Floating-point round to integral, using current rounding mode"},
            {"FRINTM", "Floating-point round to integral, toward minus infinity"},
            {"FRINTN", "Floating-point round to integral, to nearest with ties to even"},
            {"FRINTP", "Floating-point round to integral, toward plus infinity"},
            {"FRINTX", "Floating-point round to integral exact, using current rounding mode"},
            {"FRINTZ", "Floating-point round to integral, toward zero"},
            {"FRSQRTE", "Floating-point reciprocal square root estimate"},
            {"FRSQRTS", "Floating-point reciprocal square root step"},
            {"FSCALE", "Floating-point adjust exponent"},
            {"FSQRT", "Floating-point square root"},
            {"FSUB", "Floating-point subtract"},
            {"FSUBR", "Floating-point reversed subtract"},
            {"FTMAD", "Floating-point trigonometric multiply-add coefficient"},
            {"FTMOPA", "Floating-point sparse outer product, accumulating"},
            {"FTSMUL", "Floating-point trigonometric starting value"},
            {"FTSSEL", "Floating-point trigonometric select coefficient"},
            {"FVDOT", "Multi-vector half-precision vertical dot product by indexed element to single-precision"},
            {"FVDOTB", "Multi-vector 8-bit floating-point vertical dot product by indexed element to single-precision"},
            {"FVDOTT", "Multi-vector 8-bit floating-point vertical dot product by indexed element to single-precision"},
            {"GCSB", "Guarded Control Stack barrier"},
            {"GCSSTR", "Guarded Control Stack store register"},
            {"GCSSTTR", "Guarded Control Stack store register"},
            {"GMI", "Tag mask insert"},
            {"HINT", "Hint instruction"},
            {"HISTCNT", "Count matching elements in vector"},
            {"HISTSEG", "Count matching elements in vector segments"},
            {"HLT", "Halt instruction"},
            {"HVC", "Hypervisor call"},
            {"INCB", "Increment scalar by multiple of predicate constraint element count"},
            {"INCD", "Increment scalar by multiple of predicate constraint element count"},
            {"INCH", "Increment scalar by multiple of predicate constraint element count"},
            {"INCW", "Increment scalar by multiple of predicate constraint element count"},
            {"INCP", "Increment scalar by count of true predicate elements"},
            {"INDEX", "Create index starting from and incremented by immediate"},
            {"INS", "Insert vector element from another vector element"},
            {"INSR", "Insert SIMD&FP scalar register in shifted vector"},
            {"IRG", "Insert random tag"},
            {"ISB", "Instruction synchronization barrier"},
            {"LASTA", "Extract element after last to SIMD&FP scalar register"},
            {"LASTB", "Extract last element to SIMD&FP scalar register"},
            {"LASTP", "Scalar index of last true predicate element"},
            {"LD1", "Load one single-element structure to one lane of one register"},
            {"LD1B", "Gather load unsigned bytes to vector"},
            {"LD1D", "Gather load doublewords to vector"},
            {"LD1H", "Gather load unsigned halfwords to vector"},
            {"LD1Q", "Gather load quadwords"},
            {"LD1R", "Load one single-element structure and replicate to all lanes"},
            {"LD1RB", "Load and broadcast unsigned byte to vector"},
            {"LD1RD", "Load and broadcast doubleword to vector"},
            {"LD1RH", "Load and broadcast unsigned halfword to vector"},
            {"LD1ROB", "Contiguous load and replicate thirty-two bytes"},
            {"LD1ROD", "Contiguous load and replicate four doublewords"},
            {"LD1ROH", "Contiguous load and replicate sixteen halfwords"},
            {"LD1ROW", "Contiguous load and replicate eight words"},
            {"LD1RQB", "Contiguous load and replicate sixteen bytes"},
            {"LD1RQD", "Contiguous load and replicate two doublewords"},
            {"LD1RQH", "Contiguous load and replicate eight halfwords"},
            {"LD1RQW", "Contiguous load and replicate four words"},
            {"LD1RSB", "Load and broadcast signed byte to vector"},
            {"LD1RSH", "Load and broadcast signed halfword to vector"},
            {"LD1RSW", "Load and broadcast signed word to vector"},
            {"LD1RW", "Load and broadcast unsigned word to vector"},
            {"LD1SB", "Gather load signed bytes to vector"},
            {"LD1SH", "Gather load signed halfwords to vector"},
            {"LD1SW", "Gather load signed words to vector"},
            {"LD1W", "Gather load unsigned words to vector"},
            {"LD2", "Load multiple 2-element structures to two registers"},
            {"LD2B", "Contiguous load two-byte structures to two vectors"},
            {"LD2D", "Contiguous load two-doubleword structures to two vectors"},
            {"LD2H", "Contiguous load two-halfword structures to two vectors"},
            {"LD2Q", "Contiguous load two-quadword structures to two vectors"},
            {"LD2R", "Load single 2-element structure and replicate to all lanes of two registers"},
            {"LD2W", "Contiguous load two-word structures to two vectors"},
            {"LD3", "Load multiple 3-element structures to three registers"},
            {"LD3B", "Contiguous load three-byte structures to three vectors"},
            {"LD3D", "Contiguous load three-doubleword structures to three vectors"},
            {"LD3H", "Contiguous load three-halfword structures to three vectors"},
            {"LD3Q", "Contiguous load three-quadword structures to three vectors"},
            {"LD3R", "Load single 3-element structure and replicate to all lanes of three registers"},
            {"LD3W", "Contiguous load three-word structures to three vectors"},
            {"LD4", "Load multiple 4-element structures to four registers"},
            {"LD4B", "Contiguous load four-byte structures to four vectors"},
            {"LD4D", "Contiguous load four-doubleword structures to four vectors"},
            {"LD4H", "Contiguous load four-halfword structures to four vectors"},
            {"LD4Q", "Contiguous load four-quadword structures to four vectors"},
            {"LD4R", "Load single 4-element structure and replicate to all lanes of four registers"},
            {"LD4W", "Contiguous load four-word structures to four vectors"},
            {"LD64B", "Single-copy atomic 64-byte Load"},
            {"LDADD", "Atomic add on word or doubleword"},
            {"LDADDA", "Atomic add on word or doubleword"},
            {"LDADDAL", "Atomic add on word or doubleword"},
            {"LDADDL", "Atomic add on word or doubleword"},
            {"LDADDB", "Atomic add on byte"},
            {"LDADDAB", "Atomic add on byte"},
            {"LDADDALB", "Atomic add on byte"},
            {"LDADDLB", "Atomic add on byte"},
            {"LDADDH", "Atomic add on halfword"},
            {"LDADDAH", "Atomic add on halfword"},
            {"LDADDALH", "Atomic add on halfword"},
            {"LDADDLH", "Atomic add on halfword"},
            {"LDAP", "Load-acquire pair of registers"},
            {"LDAP1", "Load-acquire RCpc one single-element structure to one lane of one register"},
            {"LDAPP", "Load-acquire RCpc pair of registers"},
            {"LDAPR", "Load-acquire RCpc register"},
            {"LDAPRB", "Load-acquire RCpc register byte"},
            {"LDAPRH", "Load-acquire RCpc register halfword"},
            {"LDAPUR", "Load-acquire RCpc register"},
            {"LDAPURB", "Load-acquire RCpc register byte"},
            {"LDAPURH", "Load-acquire RCpc register halfword"},
            {"LDAPURSB", "Load-acquire RCpc register signed byte"},
            {"LDAPURSH", "Load-acquire RCpc register signed halfword"},
            {"LDAPURSW", "Load-acquire RCpc register signed word"},
            {"LDAR", "Load-acquire register"},
            {"LDARB", "Load-acquire register byte"},
            {"LDARH", "Load-acquire register halfword"},
            {"LDATXR", "Load-acquire unprivileged exclusive register"},
            {"LDAXP", "Load-acquire exclusive pair of registers"},
            {"LDAXR", "Load-acquire exclusive register"},
            {"LDAXRB", "Load-acquire exclusive register byte"},
            {"LDAXRH", "Load-acquire exclusive register halfword"},
            {"LDBFADD", "Atomic BFloat16 add"},
            {"LDBFADDA", "Atomic BFloat16 add"},
            {"LDBFADDAL", "Atomic BFloat16 add"},
            {"LDBFADDL", "Atomic BFloat16 add"},
            {"LDBFMAX", "Atomic BFloat16 maximum"},
            {"LDBFMAXA", "Atomic BFloat16 maximum"},
            {"LDBFMAXAL", "Atomic BFloat16 maximum"},
            {"LDBFMAXL", "Atomic BFloat16 maximum"},
            {"LDBFMAXNM", "Atomic BFloat16 maximum number"},
            {"LDBFMAXNMA", "Atomic BFloat16 maximum number"},
            {"LDBFMAXNMAL", "Atomic BFloat16 maximum number"},
            {"LDBFMAXNML", "Atomic BFloat16 maximum number"},
            {"LDBFMIN", "Atomic BFloat16 minimum"},
            {"LDBFMINA", "Atomic BFloat16 minimum"},
            {"LDBFMINAL", "Atomic BFloat16 minimum"},
            {"LDBFMINL", "Atomic BFloat16 minimum"},
            {"LDBFMINNM", "Atomic BFloat16 minimum number"},
            {"LDBFMINNMA", "Atomic BFloat16 minimum number"},
            {"LDBFMINNMAL", "Atomic BFloat16 minimum number"},
            {"LDBFMINNML", "Atomic BFloat16 minimum number"},
            {"LDCLR", "Atomic bit clear on word or doubleword"},
            {"LDCLRA", "Atomic bit clear on word or doubleword"},
            {"LDCLRAL", "Atomic bit clear on word or doubleword"},
            {"LDCLRL", "Atomic bit clear on word or doubleword"},
            {"LDCLRB", "Atomic bit clear on byte"},
            {"LDCLRAB", "Atomic bit clear on byte"},
            {"LDCLRALB", "Atomic bit clear on byte"},
            {"LDCLRLB", "Atomic bit clear on byte"},
            {"LDCLRH", "Atomic bit clear on halfword"},
            {"LDCLRAH", "Atomic bit clear on halfword"},
            {"LDCLRALH", "Atomic bit clear on halfword"},
            {"LDCLRLH", "Atomic bit clear on halfword"},
            {"LDCLRP", "Atomic bit clear on quadword"},
            {"LDCLRPA", "Atomic bit clear on quadword"},
            {"LDCLRPAL", "Atomic bit clear on quadword"},
            {"LDCLRPL", "Atomic bit clear on quadword"},
            {"LDEOR", "Atomic exclusive-OR on word or doubleword"},
            {"LDEORA", "Atomic exclusive-OR on word or doubleword"},
            {"LDEORAL", "Atomic exclusive-OR on word or doubleword"},
            {"LDEORL", "Atomic exclusive-OR on word or doubleword"},
            {"LDEORB", "Atomic exclusive-OR on byte"},
            {"LDEORAB", "Atomic exclusive-OR on byte"},
            {"LDEORALB", "Atomic exclusive-OR on byte"},
            {"LDEORLB", "Atomic exclusive-OR on byte"},
            {"LDEORH", "Atomic exclusive-OR on halfword"},
            {"LDEORAH", "Atomic exclusive-OR on halfword"},
            {"LDEORALH", "Atomic exclusive-OR on halfword"},
            {"LDEORLH", "Atomic exclusive-OR on halfword"},
            {"LDFADD", "Atomic floating-point add"},
            {"LDFADDA", "Atomic floating-point add"},
            {"LDFADDAL", "Atomic floating-point add"},
            {"LDFADDL", "Atomic floating-point add"},
            {"LDFF1B", "Gather load first-fault unsigned bytes to vector"},
            {"LDFF1D", "Gather load first-fault doublewords to vector"},
            {"LDFF1H", "Gather load first-fault unsigned halfwords to vector"},
            {"LDFF1SB", "Gather load first-fault signed bytes to vector"},
            {"LDFF1SH", "Gather load first-fault signed halfwords to vector"},
            {"LDFF1SW", "Gather load first-fault signed words to vector"},
            {"LDFF1W", "Gather load first-fault unsigned words to vector"},
            {"LDFMAX", "Atomic floating-point maximum"},
            {"LDFMAXA", "Atomic floating-point maximum"},
            {"LDFMAXAL", "Atomic floating-point maximum"},
            {"LDFMAXL", "Atomic floating-point maximum"},
            {"LDFMAXNM", "Atomic floating-point maximum number"},
            {"LDFMAXNMA", "Atomic floating-point maximum number"},
            {"LDFMAXNMAL", "Atomic floating-point maximum number"},
            {"LDFMAXNML", "Atomic floating-point maximum number"},
            {"LDFMIN", "Atomic floating-point minimum"},
            {"LDFMINA", "Atomic floating-point minimum"},
            {"LDFMINAL", "Atomic floating-point minimum"},
            {"LDFMINL", "Atomic floating-point minimum"},
            {"LDFMINNM", "Atomic floating-point minimum number"},
            {"LDFMINNMA", "Atomic floating-point minimum number"},
            {"LDFMINNMAL", "Atomic floating-point minimum number"},
            {"LDFMINNML", "Atomic floating-point minimum number"},
            {"LDG", "Load Allocation Tag"},
            {"LDGM", "Load tag multiple"},
            {"LDIAPP", "Load-Acquire RCpc ordered pair of registers"},
            {"LDLAR", "Load LOAcquire register"},
            {"LDLARB", "Load LOAcquire register byte"},
            {"LDLARH", "Load LOAcquire register halfword"},
            {"LDNF1B", "Contiguous load non-fault unsigned bytes to vector"},
            {"LDNF1D", "Contiguous load non-fault doublewords to vector"},
            {"LDNF1H", "Contiguous load non-fault unsigned halfwords to vector"},
            {"LDNF1SB", "Contiguous load non-fault signed bytes to vector"},
            {"LDNF1SH", "Contiguous load non-fault signed halfwords to vector"},
            {"LDNF1SW", "Contiguous load non-fault signed words to vector"},
            {"LDNF1W", "Contiguous load non-fault unsigned words to vector"},
            {"LDNP", "Load pair of registers, with non-temporal hint"},
            {"LDNT1B", "Gather load non-temporal unsigned bytes"},
            {"LDNT1D", "Gather load non-temporal unsigned doublewords"},
            {"LDNT1H", "Gather load non-temporal unsigned halfwords"},
            {"LDNT1SB", "Gather load non-temporal signed bytes"},
            {"LDNT1SH", "Gather load non-temporal signed halfwords"},
            {"LDNT1SW", "Gather load non-temporal signed words"},
            {"LDNT1W", "Gather load non-temporal unsigned words"},
            {"LDP", "Load pair of registers"},
            {"LDPSW", "Load pair of registers signed word"},
            {"LDR", "Load register"},
            {"LDRAA", "Load register, with pointer authentication"},
            {"LDRAB", "Load register, with pointer authentication"},
            {"LDRB", "Load register byte"},
            {"LDRH", "Load register halfword"},
            {"LDRSB", "Load register signed byte"},
            {"LDRSH", "Load register signed halfword"},
            {"LDRSW", "Load register signed word"},
            {"LDSET", "Atomic bit set on word or doubleword"},
            {"LDSETA", "Atomic bit set on word or doubleword"},
            {"LDSETAL", "Atomic bit set on word or doubleword"},
            {"LDSETL", "Atomic bit set on word or doubleword"},
            {"LDSETB", "Atomic bit set on byte"},
            {"LDSETAB", "Atomic bit set on byte"},
            {"LDSETALB", "Atomic bit set on byte"},
            {"LDSETLB", "Atomic bit set on byte"},
            {"LDSETH", "Atomic bit set on halfword"},
            {"LDSETAH", "Atomic bit set on halfword"},
            {"LDSETALH", "Atomic bit set on halfword"},
            {"LDSETLH", "Atomic bit set on halfword"},
            {"LDSETP", "Atomic bit set on quadword"},
            {"LDSETPA", "Atomic bit set on quadword"},
            {"LDSETPAL", "Atomic bit set on quadword"},
            {"LDSETPL", "Atomic bit set on quadword"},
            {"LDSMAX", "Atomic signed maximum on word or doubleword"},
            {"LDSMAXA", "Atomic signed maximum on word or doubleword"},
            {"LDSMAXAL", "Atomic signed maximum on word or doubleword"},
            {"LDSMAXL", "Atomic signed maximum on word or doubleword"},
            {"LDSMAXB", "Atomic signed maximum on byte"},
            {"LDSMAXAB", "Atomic signed maximum on byte"},
            {"LDSMAXALB", "Atomic signed maximum on byte"},
            {"LDSMAXLB", "Atomic signed maximum on byte"},
            {"LDSMAXH", "Atomic signed maximum on halfword"},
            {"LDSMAXAH", "Atomic signed maximum on halfword"},
            {"LDSMAXALH", "Atomic signed maximum on halfword"},
            {"LDSMAXLH", "Atomic signed maximum on halfword"},
            {"LDSMIN", "Atomic signed minimum on word or doubleword"},
            {"LDSMINA", "Atomic signed minimum on word or doubleword"},
            {"LDSMINAL", "Atomic signed minimum on word or doubleword"},
            {"LDSMINL", "Atomic signed minimum on word or doubleword"},
            {"LDSMINB", "Atomic signed minimum on byte"},
            {"LDSMINAB", "Atomic signed minimum on byte"},
            {"LDSMINALB", "Atomic signed minimum on byte"},
            {"LDSMINLB", "Atomic signed minimum on byte"},
            {"LDSMINH", "Atomic signed minimum on halfword"},
            {"LDSMINAH", "Atomic signed minimum on halfword"},
            {"LDSMINALH", "Atomic signed minimum on halfword"},
            {"LDSMINLH", "Atomic signed minimum on halfword"},
            {"LDTADD", "Atomic add unprivileged"},
            {"LDTADDA", "Atomic add unprivileged"},
            {"LDTADDAL", "Atomic add unprivileged"},
            {"LDTADDL", "Atomic add unprivileged"},
            {"LDTCLR", "Atomic bit clear unprivileged"},
            {"LDTCLRA", "Atomic bit clear unprivileged"},
            {"LDTCLRAL", "Atomic bit clear unprivileged"},
            {"LDTCLRL", "Atomic bit clear unprivileged"},
            {"LDTNP", "Load unprivileged pair of registers, with non-temporal hint"},
            {"LDTP", "Load unprivileged pair of registers"},
            {"LDTR", "Load register"},
            {"LDTRB", "Load register byte"},
            {"LDTRH", "Load register halfword"},
            {"LDTRSB", "Load register signed byte"},
            {"LDTRSH", "Load register signed halfword"},
            {"LDTRSW", "Load register signed word"},
            {"LDTSET", "Atomic bit set unprivileged"},
            {"LDTSETA", "Atomic bit set unprivileged"},
            {"LDTSETAL", "Atomic bit set unprivileged"},
            {"LDTSETL", "Atomic bit set unprivileged"},
            {"LDTXR", "Load unprivileged exclusive register"},
            {"LDUMAX", "Atomic unsigned maximum on word or doubleword"},
            {"LDUMAXA", "Atomic unsigned maximum on word or doubleword"},
            {"LDUMAXAL", "Atomic unsigned maximum on word or doubleword"},
            {"LDUMAXL", "Atomic unsigned maximum on word or doubleword"},
            {"LDUMAXB", "Atomic unsigned maximum on byte"},
            {"LDUMAXAB", "Atomic unsigned maximum on byte"},
            {"LDUMAXALB", "Atomic unsigned maximum on byte"},
            {"LDUMAXLB", "Atomic unsigned maximum on byte"},
            {"LDUMAXH", "Atomic unsigned maximum on halfword"},
            {"LDUMAXAH", "Atomic unsigned maximum on halfword"},
            {"LDUMAXALH", "Atomic unsigned maximum on halfword"},
            {"LDUMAXLH", "Atomic unsigned maximum on halfword"},
            {"LDUMIN", "Atomic unsigned minimum on word or doubleword"},
            {"LDUMINA", "Atomic unsigned minimum on word or doubleword"},
            {"LDUMINAL", "Atomic unsigned minimum on word or doubleword"},
            {"LDUMINL", "Atomic unsigned minimum on word or doubleword"},
            {"LDUMINB", "Atomic unsigned minimum on byte"},
            {"LDUMINAB", "Atomic unsigned minimum on byte"},
            {"LDUMINALB", "Atomic unsigned minimum on byte"},
            {"LDUMINLB", "Atomic unsigned minimum on byte"},
            {"LDUMINH", "Atomic unsigned minimum on halfword"},
            {"LDUMINAH", "Atomic unsigned minimum on halfword"},
            {"LDUMINALH", "Atomic unsigned minimum on halfword"},
            {"LDUMINLH", "Atomic unsigned minimum on halfword"},
            {"LDUR", "Load register"},
            {"LDURB", "Load register byte"},
            {"LDURH", "Load register halfword"},
            {"LDURSB", "Load register signed byte"},
            {"LDURSH", "Load register signed halfword"},
            {"LDURSW", "Load register signed word"},
            {"LDXP", "Load exclusive pair of registers"},
            {"LDXR", "Load exclusive register"},
            {"LDXRB", "Load exclusive register byte"},
            {"LDXRH", "Load exclusive register halfword"},
            {"LSL", "Logical shift left by vector"},
            {"LSLR", "Reversed logical shift left by vector"},
            {"LSLV", "Logical shift left variable"},
            {"LSR", "Logical shift right by vector"},
            {"LSRR", "Reversed logical shift right by vector"},
            {"LSRV", "Logical shift right variable"},
            {"LUTI2", "Lookup table read with 2-bit indices"},
            {"LUTI4", "Lookup table read with 4-bit indices"},
            {"LUTI6", "Lookup table read with 6-bit indices"},
            {"MAD", "Multiply-add to multiplicand"},
            {"MADD", "Multiply-add"},
            {"MADDPT", "Multiply-add checked pointer"},
            {"MADPT", "Multiply-add checked pointer vectors to multiplicand"},
            {"MATCH", "Detect any matching elements, setting the condition flags"},
            {"MLA", "Multiply-add"},
            {"MLAPT", "Multiply-add checked pointer vectors"},
            {"MLS", "Multiply-subtract"},
            {"MOVA", "Move ZA tile slice to Z vector"},
            {"MOVAZ", "Move and zero ZA tile slice to Z vector"},
            {"MOVI", "Move immediate"},
            {"MOVK", "Move wide with keep"},
            {"MOVN", "Move wide with NOT"},
            {"MOVPRFX", "Move prefix"},
            {"MOVT", "Move vector register to ZT0"},
            {"MOVZ", "Move wide with zero"},
            {"MRRS", "Move System register to two adjacent general-purpose registers"},
            {"MRS", "Move System register to general-purpose register"},
            {"MSB", "Multiply-subtract to multiplicand"},
            {"MSR", "Move immediate value to special register"},
            {"MSRR", "Move two adjacent general-purpose registers to System register"},
            {"MSUB", "Multiply-subtract"},
            {"MSUBPT", "Multiply-subtract checked pointer"},
            {"MUL", "Multiply"},
            {"MVNI", "Move inverted immediate"},
            {"NAND", "Bitwise NAND predicates"},
            {"NANDS", "Bitwise NAND predicates, setting the condition flags"},
            {"NBSL", "Bitwise inverted select"},
            {"NEG", "Negate"},
            {"NMATCH", "Detect no matching elements, setting the condition flags"},
            {"NOP", "No operation"},
            {"NOR", "Bitwise NOR predicates"},
            {"NORS", "Bitwise NOR predicates, setting the condition flags"},
            {"NOT", "Bitwise NOT"},
            {"ORN", "Bitwise OR NOT"},
            {"ORNS", "Bitwise inclusive OR inverted predicate, setting the condition flags"},
            {"ORQV", "Bitwise inclusive OR reduction of quadword vector segments"},
            {"ORR", "Bitwise OR"},
            {"ORRS", "Bitwise inclusive OR predicates, setting the condition flags"},
            {"ORV", "Bitwise inclusive OR reduction to scalar"},
            {"PACDA", "Pointer Authentication Code for data address, using key A"},
            {"PACDZA", "Pointer Authentication Code for data address, using key A"},
            {"PACDB", "Pointer Authentication Code for data address, using key B"},
            {"PACDZB", "Pointer Authentication Code for data address, using key B"},
            {"PACGA", "Pointer Authentication Code, using generic key"},
            {"PACIA", "Pointer Authentication Code for instruction address, using key A"},
            {"PACIA1716", "Pointer Authentication Code for instruction address, using key A"},
            {"PACIASP", "Pointer Authentication Code for instruction address, using key A"},
            {"PACIAZ", "Pointer Authentication Code for instruction address, using key A"},
            {"PACIZA", "Pointer Authentication Code for instruction address, using key A"},
            {"PACIA171615", "Pointer Authentication Code for instruction address, using key A"},
            {"PACIASPPC", "Pointer Authentication Code for return address, using key A"},
            {"PACIB", "Pointer Authentication Code for instruction address, using key B"},
            {"PACIB1716", "Pointer Authentication Code for instruction address, using key B"},
            {"PACIBSP", "Pointer Authentication Code for instruction address, using key B"},
            {"PACIBZ", "Pointer Authentication Code for instruction address, using key B"},
            {"PACIZB", "Pointer Authentication Code for instruction address, using key B"},
            {"PACIB171615", "Pointer Authentication Code for instruction address, using key B"},
            {"PACIBSPPC", "Pointer Authentication Code for return address, using key B"},
            {"PACM", "Pointer authentication modifier"},
            {"PACNBIASPPC", "Pointer Authentication Code for return address, using key A, not a branch target"},
            {"PACNBIBSPPC", "Pointer Authentication Code for return address, using key B, not a branch target"},
            {"PEXT", "Predicate extract from predicate-as-counter"},
            {"PFALSE", "Set all predicate elements to false"},
            {"PFIRST", "Set the First active predicate element to true"},
            {"PMLAL", "Multi-vector polynomial multiply long and accumulate"},
            {"PMOV", "Move predicate to vector"},
            {"PMUL", "Polynomial multiply"},
            {"PMULL", "Polynomial multiply long"},
            {"PMULL2", "Polynomial multiply long"},
            {"PMULLB", "Polynomial multiply long"},
            {"PMULLT", "Polynomial multiply long"},
            {"PNEXT", "Find next active predicate"},
            {"PRFB", "Gather prefetch bytes"},
            {"PRFD", "Gather prefetch doublewords"},
            {"PRFH", "Gather prefetch halfwords"},
            {"PRFM", "Prefetch memory"},
            {"PRFUM", "Prefetch memory"},
            {"PRFW", "Gather prefetch words"},
            {"PSB", "Profiling synchronization barrier"},
            {"PSEL", "Predicate select between predicate register or all-false"},
            {"PTEST", "Set condition flags for predicate"},
            {"PTRUE", "Initialize predicate from named constraint"},
            {"PTRUES", "Initialize predicate from named constraint and set the condition flags"},
            {"PUNPKHI", "Unpack and widen half of predicate"},
            {"PUNPKLO", "Unpack and widen half of predicate"},
            {"RADDHN", "Rounding add returning high narrow"},
            {"RADDHN2", "Rounding add returning high narrow"},
            {"RADDHNB", "Rounding add narrow high part"},
            {"RADDHNT", "Rounding add narrow high part"},
            {"RAX1", "Bitwise rotate left by 1 and exclusive-OR"},
            {"RBIT", "Reverse bits"},
            {"RCWCAS", "Read check write compare and swap doubleword in memory"},
            {"RCWCASA", "Read check write compare and swap doubleword in memory"},
            {"RCWCASAL", "Read check write compare and swap doubleword in memory"},
            {"RCWCASL", "Read check write compare and swap doubleword in memory"},
            {"RCWCASP", "Read check write compare and swap quadword in memory"},
            {"RCWCASPA", "Read check write compare and swap quadword in memory"},
            {"RCWCASPAL", "Read check write compare and swap quadword in memory"},
            {"RCWCASPL", "Read check write compare and swap quadword in memory"},
            {"RCWCLR", "Read check write atomic bit clear on doubleword in memory"},
            {"RCWCLRA", "Read check write atomic bit clear on doubleword in memory"},
            {"RCWCLRAL", "Read check write atomic bit clear on doubleword in memory"},
            {"RCWCLRL", "Read check write atomic bit clear on doubleword in memory"},
            {"RCWCLRP", "Read check write atomic bit clear on quadword in memory"},
            {"RCWCLRPA", "Read check write atomic bit clear on quadword in memory"},
            {"RCWCLRPAL", "Read check write atomic bit clear on quadword in memory"},
            {"RCWCLRPL", "Read check write atomic bit clear on quadword in memory"},
            {"RCWSCAS", "Read check write software compare and swap doubleword in memory"},
            {"RCWSCASA", "Read check write software compare and swap doubleword in memory"},
            {"RCWSCASAL", "Read check write software compare and swap doubleword in memory"},
            {"RCWSCASL", "Read check write software compare and swap doubleword in memory"},
            {"RCWSCASP", "Read check write software compare and swap quadword in memory"},
            {"RCWSCASPA", "Read check write software compare and swap quadword in memory"},
            {"RCWSCASPAL", "Read check write software compare and swap quadword in memory"},
            {"RCWSCASPL", "Read check write software compare and swap quadword in memory"},
            {"RCWSCLR", "Read check write software atomic bit clear on doubleword in memory"},
            {"RCWSCLRA", "Read check write software atomic bit clear on doubleword in memory"},
            {"RCWSCLRAL", "Read check write software atomic bit clear on doubleword in memory"},
            {"RCWSCLRL", "Read check write software atomic bit clear on doubleword in memory"},
            {"RCWSCLRP", "Read check write software atomic bit clear on quadword in memory"},
            {"RCWSCLRPA", "Read check write software atomic bit clear on quadword in memory"},
            {"RCWSCLRPAL", "Read check write software atomic bit clear on quadword in memory"},
            {"RCWSCLRPL", "Read check write software atomic bit clear on quadword in memory"},
            {"RCWSET", "Read check write atomic bit set on doubleword in memory"},
            {"RCWSETA", "Read check write atomic bit set on doubleword in memory"},
            {"RCWSETAL", "Read check write atomic bit set on doubleword in memory"},
            {"RCWSETL", "Read check write atomic bit set on doubleword in memory"},
            {"RCWSETP", "Read check write atomic bit set on quadword in memory"},
            {"RCWSETPA", "Read check write atomic bit set on quadword in memory"},
            {"RCWSETPAL", "Read check write atomic bit set on quadword in memory"},
            {"RCWSETPL", "Read check write atomic bit set on quadword in memory"},
            {"RCWSSET", "Read check write software atomic bit set on doubleword in memory"},
            {"RCWSSETA", "Read check write software atomic bit set on doubleword in memory"},
            {"RCWSSETAL", "Read check write software atomic bit set on doubleword in memory"},
            {"RCWSSETL", "Read check write software atomic bit set on doubleword in memory"},
            {"RCWSSETP", "Read check write software atomic bit set on quadword in memory"},
            {"RCWSSETPA", "Read check write software atomic bit set on quadword in memory"},
            {"RCWSSETPAL", "Read check write software atomic bit set on quadword in memory"},
            {"RCWSSETPL", "Read check write software atomic bit set on quadword in memory"},
            {"RCWSSWP", "Read check write software swap doubleword in memory"},
            {"RCWSSWPA", "Read check write software swap doubleword in memory"},
            {"RCWSSWPAL", "Read check write software swap doubleword in memory"},
            {"RCWSSWPL", "Read check write software swap doubleword in memory"},
            {"RCWSSWPP", "Read check write software swap quadword in memory"},
            {"RCWSSWPPA", "Read check write software swap quadword in memory"},
            {"RCWSSWPPAL", "Read check write software swap quadword in memory"},
            {"RCWSSWPPL", "Read check write software swap quadword in memory"},
            {"RCWSWP", "Read check write swap doubleword in memory"},
            {"RCWSWPA", "Read check write swap doubleword in memory"},
            {"RCWSWPAL", "Read check write swap doubleword in memory"},
            {"RCWSWPL", "Read check write swap doubleword in memory"},
            {"RCWSWPP", "Read check write swap quadword in memory"},
            {"RCWSWPPA", "Read check write swap quadword in memory"},
            {"RCWSWPPAL", "Read check write swap quadword in memory"},
            {"RCWSWPPL", "Read check write swap quadword in memory"},
            {"RDFFR", "Read the first-fault register"},
            {"RDFFRS", "Return predicate of successfully loaded elements, setting the condition flags"},
            {"RDSVL", "Read multiple of Streaming SVE vector register size to scalar register"},
            {"RDVL", "Read multiple of vector register size to scalar register"},
            {"RET", "Return from subroutine"},
            {"RETAA", "Return from subroutine, with pointer authentication"},
            {"RETAB", "Return from subroutine, with pointer authentication"},
            {"RETAASPPC", "Return from subroutine, with enhanced pointer authentication using an immediate offset"},
            {"RETABSPPC", "Return from subroutine, with enhanced pointer authentication using an immediate offset"},
            {"RETAASPPCR", "Return from subroutine, with enhanced pointer authentication using a register"},
            {"RETABSPPCR", "Return from subroutine, with enhanced pointer authentication using a register"},
            {"REV", "Reverse bytes"},
            {"REV16", "Reverse bytes in 16-bit halfwords"},
            {"REV32", "Reverse bytes in 32-bit words"},
            {"REV64", "Reverse elements in 64-bit doublewords"},
            {"REVB", "Reverse bytes / halfwords / words within elements"},
            {"REVH", "Reverse bytes / halfwords / words within elements"},
            {"REVW", "Reverse bytes / halfwords / words within elements"},
            {"REVD", "Reverse 64-bit doublewords in elements"},
            {"RMIF", "Rotate, mask insert flags"},
            {"RORV", "Rotate right variable"},
            {"RPRFM", "Range prefetch memory"},
            {"RSHRN", "Rounding shift right narrow"},
            {"RSHRN2", "Rounding shift right narrow"},
            {"RSHRNB", "Rounding shift right narrow by immediate"},
            {"RSHRNT", "Rounding shift right narrow by immediate"},
            {"RSUBHN", "Rounding subtract returning high narrow"},
            {"RSUBHN2", "Rounding subtract returning high narrow"},
            {"RSUBHNB", "Rounding subtract narrow high part"},
            {"RSUBHNT", "Rounding subtract narrow high part"},
            {"SABA", "Signed absolute difference and accumulate"},
            {"SABAL", "Signed absolute difference and accumulate long"},
            {"SABAL2", "Signed absolute difference and accumulate long"},
            {"SABALB", "Signed absolute difference and accumulate long"},
            {"SABALT", "Signed absolute difference and accumulate long"},
            {"SABD", "Signed absolute difference"},
            {"SABDL", "Signed absolute difference long"},
            {"SABDL2", "Signed absolute difference long"},
            {"SABDLB", "Signed absolute difference long"},
            {"SABDLT", "Signed absolute difference long"},
            {"SADALP", "Signed add and accumulate long pairwise"},
            {"SADDL", "Signed add long"},
            {"SADDL2", "Signed add long"},
            {"SADDLB", "Signed add long"},
            {"SADDLBT", "Signed add long"},
            {"SADDLP", "Signed add long pairwise"},
            {"SADDLT", "Signed add long"},
            {"SADDLV", "Signed add long across vector"},
            {"SADDV", "Signed add reduction to scalar"},
            {"SADDW", "Signed add wide"},
            {"SADDW2", "Signed add wide"},
            {"SADDWB", "Signed add wide"},
            {"SADDWT", "Signed add wide"},
            {"SB", "Speculation barrier"},
            {"SBC", "Subtract with carry"},
            {"SBCLB", "Subtract with carry long"},
            {"SBCLT", "Subtract with carry long"},
            {"SBCS", "Subtract with carry, setting flags"},
            {"SBFM", "Signed bitfield move"},
            {"SCLAMP", "Signed clamp to minimum/maximum"},
            {"SCVTF", "Signed integer convert to floating-point"},
            {"SCVTFLT", "Signed integer convert to floating-point"},
            {"SDIV", "Signed divide"},
            {"SDIVR", "Signed reversed divide"},
            {"SDOT", "Signed integer dot product"},
            {"SEL", "Multi-vector conditional select"},
            {"SETF8", "Evaluation of 8-bit or 16-bit flag values"},
            {"SETF16", "Evaluation of 8-bit or 16-bit flag values"},
            {"SETFFR", "Initialize the first-fault register to all true"},
            {"SETGP", "Memory set with tag setting"},
            {"SETGM", "Memory set with tag setting"},
            {"SETGE", "Memory set with tag setting"},
            {"SETGPN", "Memory set with tag setting, non-temporal"},
            {"SETGMN", "Memory set with tag setting, non-temporal"},
            {"SETGEN", "Memory set with tag setting, non-temporal"},
            {"SETGPT", "Memory set with tag setting, unprivileged"},
            {"SETGMT", "Memory set with tag setting, unprivileged"},
            {"SETGET", "Memory set with tag setting, unprivileged"},
            {"SETGPTN", "Memory set with tag setting, unprivileged and non-temporal"},
            {"SETGMTN", "Memory set with tag setting, unprivileged and non-temporal"},
            {"SETGETN", "Memory set with tag setting, unprivileged and non-temporal"},
            {"SETP", "Memory set"},
            {"SETM", "Memory set"},
            {"SETE", "Memory set"},
            {"SETPN", "Memory set, non-temporal"},
            {"SETMN", "Memory set, non-temporal"},
            {"SETEN", "Memory set, non-temporal"},
            {"SETPT", "Memory set, unprivileged"},
            {"SETMT", "Memory set, unprivileged"},
            {"SETET", "Memory set, unprivileged"},
            {"SETPTN", "Memory set, unprivileged and non-temporal"},
            {"SETMTN", "Memory set, unprivileged and non-temporal"},
            {"SETETN", "Memory set, unprivileged and non-temporal"},
            {"SEV", "Send event"},
            {"SEVL", "Send event local"},
            {"SHA1C", "SHA1 hash update"},
            {"SHA1H", "SHA1 fixed rotate"},
            {"SHA1M", "SHA1 hash update"},
            {"SHA1P", "SHA1 hash update"},
            {"SHA1SU0", "SHA1 schedule update 0"},
            {"SHA1SU1", "SHA1 schedule update 1"},
            {"SHA256H", "SHA256 hash update"},
            {"SHA256H2", "SHA256 hash update"},
            {"SHA256SU0", "SHA256 schedule update 0"},
            {"SHA256SU1", "SHA256 schedule update 1"},
            {"SHA512H", "SHA512 hash update part 1"},
            {"SHA512H2", "SHA512 hash update part 2"},
            {"SHA512SU0", "SHA512 schedule update 0"},
            {"SHA512SU1", "SHA512 schedule update 1"},
            {"SHADD", "Signed halving add"},
            {"SHL", "Shift left"},
            {"SHLL", "Shift left long"},
            {"SHLL2", "Shift left long"},
            {"SHRN", "Shift right narrow"},
            {"SHRN2", "Shift right narrow"},
            {"SHRNB", "Shift right narrow by immediate"},
            {"SHRNT", "Shift right narrow by immediate"},
            {"SHSUB", "Signed halving subtract"},
            {"SHSUBR", "Signed halving subtract reversed"},
            {"SHUH", "Shared update hint"},
            {"SLI", "Shift left and insert"},
            {"SM3PARTW1", "SM3PARTW1"},
            {"SM3PARTW2", "SM3PARTW2"},
            {"SM3SS1", "SM3SS1"},
            {"SM3TT1A", "SM3TT1A"},
            {"SM3TT1B", "SM3TT1B"},
            {"SM3TT2A", "SM3TT2A"},
            {"SM3TT2B", "SM3TT2B"},
            {"SM4E", "SM4 encode"},
            {"SM4EKEY", "SM4 key"},
            {"SMADDL", "Signed multiply-add long"},
            {"SMAX", "Signed maximum"},
            {"SMAXP", "Signed maximum pairwise"},
            {"SMAXQV", "Signed maximum reduction of quadword vector segments"},
            {"SMAXV", "Signed maximum reduction to scalar"},
            {"SMC", "Secure monitor call"},
            {"SMIN", "Signed minimum"},
            {"SMINP", "Signed minimum pairwise"},
            {"SMINQV", "Signed minimum reduction of quadword vector segments"},
            {"SMINV", "Signed minimum reduction to scalar"},
            {"SMLAL", "Signed multiply-add long"},
            {"SMLAL2", "Signed multiply-add long"},
            {"SMLALB", "Signed multiply-add long"},
            {"SMLALL", "Multi-vector signed integer multiply-add long long"},
            {"SMLALT", "Signed multiply-add long"},
            {"SMLSL", "Signed multiply-subtract long"},
            {"SMLSL2", "Signed multiply-subtract long"},
            {"SMLSLB", "Signed multiply-subtract long"},
            {"SMLSLL", "Multi-vector signed integer multiply-subtract long long"},
            {"SMLSLT", "Signed multiply-subtract long"},
            {"SMMLA", "Signed 8-bit integer matrix multiply-accumulate to 32-bit integer"},
            {"SMOP4A", "Signed integer quarter-tile sum of outer products, accumulating"},
            {"SMOP4S", "Signed integer quarter-tile sum of outer products, subtracting"},
            {"SMOPA", "Signed integer sum of outer products, accumulating"},
            {"SMOPS", "Signed integer sum of outer products, subtracting"},
            {"SMOV", "Signed move vector element to general-purpose register"},
            {"SMSUBL", "Signed multiply-subtract long"},
            {"SMULH", "Signed multiply high"},
            {"SMULL", "Signed multiply long"},
            {"SMULL2", "Signed multiply long"},
            {"SMULLB", "Signed multiply long"},
            {"SMULLT", "Signed multiply long"},
            {"SPLICE", "Splice two vectors under predicate control"},
            {"SQABS", "Signed saturating absolute value"},
            {"SQADD", "Signed saturating add"},
            {"SQCADD", "Saturating complex integer add"},
            {"SQCVT", "Multi-vector signed saturating extract narrow"},
            {"SQCVTN", "Signed 32-bit integer saturating extract narrow to interleaved 16-bit integer"},
            {"SQCVTU", "Multi-vector signed saturating extract narrow to unsigned integer"},
            {"SQCVTUN", "Signed 32-bit integer saturating extract narrow to interleaved unsigned 16-bit integer"},
            {"SQDECB", "Signed saturating decrement scalar by multiple of 8-bit predicate constraint element count"},
            {"SQDECD", "Signed saturating decrement scalar by multiple of 64-bit predicate constraint element count"},
            {"SQDECH", "Signed saturating decrement scalar by multiple of 16-bit predicate constraint element count"},
            {"SQDECP", "Signed saturating decrement scalar by count of true predicate elements"},
            {"SQDECW", "Signed saturating decrement scalar by multiple of 32-bit predicate constraint element count"},
            {"SQDMLAL", "Signed saturating doubling multiply-add long"},
            {"SQDMLAL2", "Signed saturating doubling multiply-add long"},
            {"SQDMLALB", "Signed saturating doubling multiply-add"},
            {"SQDMLALBT", "Signed saturating doubling multiply-add"},
            {"SQDMLALT", "Signed saturating doubling multiply-add"},
            {"SQDMLSL", "Signed saturating doubling multiply-subtract long"},
            {"SQDMLSL2", "Signed saturating doubling multiply-subtract long"},
            {"SQDMLSLB", "Signed saturating doubling multiply-subtract"},
            {"SQDMLSLBT", "Signed saturating doubling multiply-subtract"},
            {"SQDMLSLT", "Signed saturating doubling multiply-subtract"},
            {"SQDMULH", "Signed saturating doubling multiply high"},
            {"SQDMULL", "Signed saturating doubling multiply long"},
            {"SQDMULL2", "Signed saturating doubling multiply long"},
            {"SQDMULLB", "Signed saturating doubling multiply"},
            {"SQDMULLT", "Signed saturating doubling multiply"},
            {"SQINCB", "Signed saturating increment scalar by multiple of 8-bit predicate constraint element count"},
            {"SQINCD", "Signed saturating increment scalar by multiple of 64-bit predicate constraint element count"},
            {"SQINCH", "Signed saturating increment scalar by multiple of 16-bit predicate constraint element count"},
            {"SQINCP", "Signed saturating increment scalar by count of true predicate elements"},
            {"SQINCW", "Signed saturating increment scalar by multiple of 32-bit predicate constraint element count"},
            {"SQNEG", "Signed saturating negate"},
            {"SQRDCMLAH", "Saturating rounding doubling complex integer multiply-add high"},
            {"SQRDMLAH", "Signed saturating rounding doubling multiply-add high"},
            {"SQRDMLSH", "Signed saturating rounding doubling multiply-subtract high"},
            {"SQRDMULH", "Signed saturating rounding doubling multiply high"},
            {"SQRSHL", "Signed saturating rounding shift left"},
            {"SQRSHLR", "Signed saturating rounding shift left reversed"},
            {"SQRSHR", "Multi-vector signed saturating rounding shift right narrow by immediate"},
            {"SQRSHRN", "Signed saturating rounded shift right narrow"},
            {"SQRSHRN2", "Signed saturating rounded shift right narrow"},
            {"SQRSHRNB", "Signed saturating rounding shift right narrow by immediate"},
            {"SQRSHRNT", "Signed saturating rounding shift right narrow by immediate"},
            {"SQRSHRU", "Multi-vector signed saturating rounding shift right narrow by immediate to unsigned integer"},
            {"SQRSHRUN", "Signed saturating rounded shift right unsigned narrow"},
            {"SQRSHRUN2", "Signed saturating rounded shift right unsigned narrow"},
            {"SQRSHRUNB", "Signed saturating rounding shift right narrow by immediate to unsigned integer"},
            {"SQRSHRUNT", "Signed saturating rounding shift right narrow by immediate to unsigned integer"},
            {"SQSHL", "Signed saturating shift left"},
            {"SQSHLR", "Signed saturating shift left reversed"},
            {"SQSHLU", "Signed saturating shift left unsigned"},
            {"SQSHRN", "Signed saturating shift right narrow"},
            {"SQSHRN2", "Signed saturating shift right narrow"},
            {"SQSHRNB", "Signed saturating shift right narrow by immediate"},
            {"SQSHRNT", "Signed saturating shift right narrow by immediate"},
            {"SQSHRUN", "Signed saturating shift right unsigned narrow"},
            {"SQSHRUN2", "Signed saturating shift right unsigned narrow"},
            {"SQSHRUNB", "Signed saturating shift right narrow by immediate to unsigned integer"},
            {"SQSHRUNT", "Signed saturating shift right narrow by immediate to unsigned integer"},
            {"SQSUB", "Signed saturating subtract"},
            {"SQSUBR", "Signed saturating subtract reversed"},
            {"SQXTN", "Signed saturating extract narrow"},
            {"SQXTN2", "Signed saturating extract narrow"},
            {"SQXTNB", "Signed saturating extract narrow"},
            {"SQXTNT", "Signed saturating extract narrow"},
            {"SQXTUN", "Signed saturating extract unsigned narrow"},
            {"SQXTUN2", "Signed saturating extract unsigned narrow"},
            {"SQXTUNB", "Signed saturating extract narrow to unsigned integer"},
            {"SQXTUNT", "Signed saturating extract narrow to unsigned integer"},
            {"SRHADD", "Signed rounding halving add"},
            {"SRI", "Shift right and insert"},
            {"SRSHL", "Signed rounding shift left"},
            {"SRSHLR", "Signed rounding shift left reversed"},
            {"SRSHR", "Signed rounding shift right"},
            {"SRSRA", "Signed rounding shift right and accumulate"},
            {"SSHL", "Signed shift left"},
            {"SSHLL", "Signed shift left long"},
            {"SSHLL2", "Signed shift left long"},
            {"SSHLLB", "Signed shift left long by immediate"},
            {"SSHLLT", "Signed shift left long by immediate"},
            {"SSHR", "Signed shift right"},
            {"SSRA", "Signed shift right and accumulate"},
            {"SSUBL", "Signed subtract long"},
            {"SSUBL2", "Signed subtract long"},
            {"SSUBLB", "Signed subtract long"},
            {"SSUBLBT", "Signed subtract long"},
            {"SSUBLT", "Signed subtract long"},
            {"SSUBLTB", "Signed subtract long"},
            {"SSUBW", "Signed subtract wide"},
            {"SSUBW2", "Signed subtract wide"},
            {"SSUBWB", "Signed subtract wide"},
            {"SSUBWT", "Signed subtract wide"},
            {"ST1", "Store a single-element structure from one lane of one register"},
            {"ST1B", "Scatter store bytes from a vector"},
            {"ST1D", "Scatter store doublewords from a vector"},
            {"ST1H", "Scatter store halfwords from a vector"},
            {"ST1Q", "Contiguous store of quadwords from 128-bit element ZA tile slice"},
            {"ST1W", "Scatter store words from a vector"},
            {"ST2", "Store multiple 2-element structures from two registers"},
            {"ST2B", "Contiguous store two-byte structures from two vectors"},
            {"ST2D", "Contiguous store two-doubleword structures from two vectors"},
            {"ST2G", "Store Allocation Tags"},
            {"ST2H", "Contiguous store two-halfword structures from two vectors"},
            {"ST2Q", "Contiguous store two-quadword structures from two vectors"},
            {"ST2W", "Contiguous store two-word structures from two vectors"},
            {"ST3", "Store multiple 3-element structures from three registers"},
            {"ST3B", "Contiguous store three-byte structures from three vectors"},
            {"ST3D", "Contiguous store three-doubleword structures from three vectors"},
            {"ST3H", "Contiguous store three-halfword structures from three vectors"},
            {"ST3Q", "Contiguous store three-quadword structures from three vectors"},
            {"ST3W", "Contiguous store three-word structures from three vectors"},
            {"ST4", "Store multiple 4-element structures from four registers"},
            {"ST4B", "Contiguous store four-byte structures from four vectors"},
            {"ST4D", "Contiguous store four-doubleword structures from four vectors"},
            {"ST4H", "Contiguous store four-halfword structures from four vectors"},
            {"ST4Q", "Contiguous store four-quadword structures from four vectors"},
            {"ST4W", "Contiguous store four-word structures from four vectors"},
            {"ST64B", "Single-copy atomic 64-byte store without status result"},
            {"ST64BV", "Single-copy atomic 64-byte store with status result"},
            {"ST64BV0", "Single-copy atomic 64-byte EL0 store with status result"},
            {"STBFADD", "Atomic BFloat16 floating-point add, without return"},
            {"STBFADDL", "Atomic BFloat16 floating-point add, without return"},
            {"STBFMAX", "Atomic BFloat16 floating-point maximum, without return"},
            {"STBFMAXL", "Atomic BFloat16 floating-point maximum, without return"},
            {"STBFMAXNM", "Atomic BFloat16 floating-point maximum number, without return"},
            {"STBFMAXNML", "Atomic BFloat16 floating-point maximum number, without return"},
            {"STBFMIN", "Atomic BFloat16 floating-point minimum, without return"},
            {"STBFMINL", "Atomic BFloat16 floating-point minimum, without return"},
            {"STBFMINNM", "Atomic BFloat16 floating-point minimum number, without return"},
            {"STBFMINNML", "Atomic BFloat16 floating-point minimum number, without return"},
            {"STCPH", "Store concurrent priority hint"},
            {"STFADD", "Atomic floating-point add, without return"},
            {"STFADDL", "Atomic floating-point add, without return"},
            {"STFMAX", "Atomic floating-point maximum, without return"},
            {"STFMAXL", "Atomic floating-point maximum, without return"},
            {"STFMAXNM", "Atomic floating-point maximum number, without return"},
            {"STFMAXNML", "Atomic floating-point maximum number, without return"},
            {"STFMIN", "Atomic floating-point minimum, without return"},
            {"STFMINL", "Atomic floating-point minimum, without return"},
            {"STFMINNM", "Atomic floating-point minimum number, without return"},
            {"STFMINNML", "Atomic floating-point minimum number, without return"},
            {"STG", "Store Allocation Tag"},
            {"STGM", "Store Allocation Tag multiple"},
            {"STGP", "Store Allocation Tag and pair of registers"},
            {"STILP", "Store-release ordered pair of registers"},
            {"STL1", "Store-release a single-element structure from one lane of one register"},
            {"STLLR", "Store LORelease register"},
            {"STLLRB", "Store LORelease register byte"},
            {"STLLRH", "Store LORelease register halfword"},
            {"STLP", "Store-release pair of registers"},
            {"STLR", "Store-release register"},
            {"STLRB", "Store-release register byte"},
            {"STLRH", "Store-release register halfword"},
            {"STLTXR", "Store-release unprivileged exclusive register"},
            {"STLUR", "Store-release register"},
            {"STLURB", "Store-release register byte"},
            {"STLURH", "Store-release register halfword"},
            {"STLXP", "Store-release exclusive pair of registers"},
            {"STLXR", "Store-release exclusive register"},
            {"STLXRB", "Store-release exclusive register byte"},
            {"STLXRH", "Store-release exclusive register halfword"},
            {"STMOPA", "Signed 8-bit integer sparse sum of outer products to 32-bit integer, accumulating"},
            {"STNP", "Store pair of registers, with non-temporal hint"},
            {"STNT1B", "Scatter store non-temporal bytes"},
            {"STNT1D", "Scatter store non-temporal doublewords"},
            {"STNT1H", "Scatter store non-temporal halfwords"},
            {"STNT1W", "Scatter store non-temporal words"},
            {"STP", "Store pair of registers"},
            {"STR", "Store register"},
            {"STRB", "Store register byte"},
            {"STRH", "Store register halfword"},
            {"STSHH", "Store shared hint"},
            {"STTNP", "Store unprivileged pair of registers, with non-temporal hint"},
            {"STTP", "Store unprivileged pair of registers"},
            {"STTR", "Store register"},
            {"STTRB", "Store register byte"},
            {"STTRH", "Store register halfword"},
            {"STTXR", "Store unprivileged exclusive register"},
            {"STUR", "Store register"},
            {"STURB", "Store register byte"},
            {"STURH", "Store register halfword"},
            {"STXP", "Store exclusive pair of registers"},
            {"STXR", "Store exclusive register"},
            {"STXRB", "Store exclusive register byte"},
            {"STXRH", "Store exclusive register halfword"},
            {"STZ2G", "Store Allocation Tags, zeroing"},
            {"STZG", "Store Allocation Tag, zeroing"},
            {"STZGM", "Store Allocation Tag and zero multiple"},
            {"SUB", "Subtract"},
            {"SUBG", "Subtract with tag"},
            {"SUBHN", "Subtract returning high narrow"},
            {"SUBHN2", "Subtract returning high narrow"},
            {"SUBHNB", "Subtract narrow high part"},
            {"SUBHNT", "Subtract narrow high part"},
            {"SUBP", "Subtract pairwise"},
            {"SUBPS", "Subtract pointer, setting flags"},
            {"SUBPT", "Subtract checked pointer"},
            {"SUBR", "Reversed subtract"},
            {"SUBS", "Subtract immediate value, setting flags"},
            {"SUDOT", "Dot product with signed and unsigned integers"},
            {"SUMLALL", "Multi-vector signed by unsigned 8-bit integer multiply-add by vector to 32-bit integer"},
            {"SUMOP4A", "Signed by unsigned integer quarter-tile sum of outer products, accumulating"},
            {"SUMOP4S", "Signed by unsigned integer quarter-tile sum of outer products, subtracting"},
            {"SUMOPA", "Signed by unsigned integer sum of outer products, accumulating"},
            {"SUMOPS", "Signed by unsigned integer sum of outer products, subtracting"},
            {"SUNPK", "Unpack and sign-extend multi-vector elements"},
            {"SUNPKHI", "Signed unpack and extend half of vector"},
            {"SUNPKLO", "Signed unpack and extend half of vector"},
            {"SUQADD", "Signed saturating unsigned add"},
            {"SUTMOPA",
             "Signed by unsigned 8-bit integer sparse sum of outer products to 32-bit integer, accumulating"},
            {"SUVDOT",
             "Multi-vector signed by unsigned 8-bit integer vertical dot product by indexed element to 32-bit integer"},
            {"SVC", "Supervisor call"},
            {"SVDOT", "Multi-vector signed integer vertical dot product by indexed element"},
            {"SWP", "Swap word or doubleword in memory"},
            {"SWPA", "Swap word or doubleword in memory"},
            {"SWPAL", "Swap word or doubleword in memory"},
            {"SWPL", "Swap word or doubleword in memory"},
            {"SWPB", "Swap byte in memory"},
            {"SWPAB", "Swap byte in memory"},
            {"SWPALB", "Swap byte in memory"},
            {"SWPLB", "Swap byte in memory"},
            {"SWPH", "Swap halfword in memory"},
            {"SWPAH", "Swap halfword in memory"},
            {"SWPALH", "Swap halfword in memory"},
            {"SWPLH", "Swap halfword in memory"},
            {"SWPP", "Swap quadword in memory"},
            {"SWPPA", "Swap quadword in memory"},
            {"SWPPAL", "Swap quadword in memory"},
            {"SWPPL", "Swap quadword in memory"},
            {"SWPT", "Swap unprivileged"},
            {"SWPTA", "Swap unprivileged"},
            {"SWPTAL", "Swap unprivileged"},
            {"SWPTL", "Swap unprivileged"},
            {"SXTB", "Signed byte / halfword / word extend"},
            {"SXTH", "Signed byte / halfword / word extend"},
            {"SXTW", "Signed byte / halfword / word extend"},
            {"SYS", "System instruction"},
            {"SYSL", "System instruction with result"},
            {"SYSP", "128-bit system instruction"},
            {"TBL", "Table vector lookup"},
            {"TBLQ", "Programmable table lookup within each quadword vector segment"},
            {"TBNZ", "Test bit and branch if nonzero"},
            {"TBX", "Table vector lookup extension"},
            {"TBXQ", "Programmable table lookup within each quadword vector segment"},
            {"TBZ", "Test bit and branch if zero"},
            {"TRN1", "Transpose vectors"},
            {"TRN2", "Transpose vectors"},
            {"TSB", "Trace synchronization barrier"},
            {"UABA", "Unsigned absolute difference and accumulate"},
            {"UABAL", "Unsigned absolute difference and accumulate long"},
            {"UABAL2", "Unsigned absolute difference and accumulate long"},
            {"UABALB", "Unsigned absolute difference and accumulate long"},
            {"UABALT", "Unsigned absolute difference and accumulate long"},
            {"UABD", "Unsigned absolute difference"},
            {"UABDL", "Unsigned absolute difference long"},
            {"UABDL2", "Unsigned absolute difference long"},
            {"UABDLB", "Unsigned absolute difference long"},
            {"UABDLT", "Unsigned absolute difference long"},
            {"UADALP", "Unsigned add and accumulate long pairwise"},
            {"UADDL", "Unsigned add long"},
            {"UADDL2", "Unsigned add long"},
            {"UADDLB", "Unsigned add long"},
            {"UADDLP", "Unsigned add long pairwise"},
            {"UADDLT", "Unsigned add long"},
            {"UADDLV", "Unsigned sum long across vector"},
            {"UADDV", "Unsigned add reduction to scalar"},
            {"UADDW", "Unsigned add wide"},
            {"UADDW2", "Unsigned add wide"},
            {"UADDWB", "Unsigned add wide"},
            {"UADDWT", "Unsigned add wide"},
            {"UBFM", "Unsigned bitfield move"},
            {"UCLAMP", "Unsigned clamp to minimum/maximum"},
            {"UCVTF", "Unsigned integer convert to floating-point"},
            {"UCVTFLT", "Unsigned integer convert to floating-point"},
            {"UDF", "Permanently undefined"},
            {"UDIV", "Unsigned divide"},
            {"UDIVR", "Unsigned reversed divide"},
            {"UDOT", "Unsigned integer dot product"},
            {"UHADD", "Unsigned halving add"},
            {"UHSUB", "Unsigned halving subtract"},
            {"UHSUBR", "Unsigned halving subtract reversed"},
            {"UMADDL", "Unsigned multiply-add long"},
            {"UMAX", "Unsigned maximum"},
            {"UMAXP", "Unsigned maximum pairwise"},
            {"UMAXQV", "Unsigned maximum reduction of quadword vector segments"},
            {"UMAXV", "Unsigned maximum across vector"},
            {"UMIN", "Unsigned minimum"},
            {"UMINP", "Unsigned minimum pairwise"},
            {"UMINQV", "Unsigned minimum reduction of quadword vector segments"},
            {"UMINV", "Unsigned minimum across vector"},
            {"UMLAL", "Unsigned multiply-add long"},
            {"UMLAL2", "Unsigned multiply-add long"},
            {"UMLALB", "Unsigned multiply-add long"},
            {"UMLALL", "Multi-vector unsigned integer multiply-add long long"},
            {"UMLALT", "Unsigned multiply-add long"},
            {"UMLSL", "Unsigned multiply-subtract long"},
            {"UMLSL2", "Unsigned multiply-subtract long"},
            {"UMLSLB", "Unsigned multiply-subtract long"},
            {"UMLSLL", "Multi-vector unsigned integer multiply-subtract long long"},
            {"UMLSLT", "Unsigned multiply-subtract long"},
            {"UMMLA", "Unsigned 8-bit integer matrix multiply-accumulate to 32-bit integer"},
            {"UMOP4A", "Unsigned integer quarter-tile sum of outer products, accumulating"},
            {"UMOP4S", "Unsigned integer quarter-tile sum of outer products, subtracting"},
            {"UMOPA", "Unsigned integer sum of outer products, accumulating"},
            {"UMOPS", "Unsigned integer sum of outer products, subtracting"},
            {"UMOV", "Unsigned move vector element to general-purpose register"},
            {"UMSUBL", "Unsigned multiply-subtract long"},
            {"UMULH", "Unsigned multiply high"},
            {"UMULL", "Unsigned multiply long"},
            {"UMULL2", "Unsigned multiply long"},
            {"UMULLB", "Unsigned multiply long"},
            {"UMULLT", "Unsigned multiply long"},
            {"UQADD", "Unsigned saturating add"},
            {"UQCVT", "Multi-vector unsigned saturating extract narrow"},
            {"UQCVTN", "Unsigned 32-bit integer saturating extract narrow to interleaved 16-bit integer"},
            {"UQDECB", "Unsigned saturating decrement scalar by multiple of 8-bit predicate constraint element count"},
            {"UQDECD", "Unsigned saturating decrement scalar by multiple of 64-bit predicate constraint element count"},
            {"UQDECH", "Unsigned saturating decrement scalar by multiple of 16-bit predicate constraint element count"},
            {"UQDECP", "Unsigned saturating decrement scalar by count of true predicate elements"},
            {"UQDECW", "Unsigned saturating decrement scalar by multiple of 32-bit predicate constraint element count"},
            {"UQINCB", "Unsigned saturating increment scalar by multiple of 8-bit predicate constraint element count"},
            {"UQINCD", "Unsigned saturating increment scalar by multiple of 64-bit predicate constraint element count"},
            {"UQINCH", "Unsigned saturating increment scalar by multiple of 16-bit predicate constraint element count"},
            {"UQINCP", "Unsigned saturating increment scalar by count of true predicate elements"},
            {"UQINCW", "Unsigned saturating increment scalar by multiple of 32-bit predicate constraint element count"},
            {"UQRSHL", "Unsigned saturating rounding shift left"},
            {"UQRSHLR", "Unsigned saturating rounding shift left reversed"},
            {"UQRSHR", "Multi-vector unsigned saturating rounding shift right narrow by immediate"},
            {"UQRSHRN", "Unsigned saturating rounded shift right narrow"},
            {"UQRSHRN2", "Unsigned saturating rounded shift right narrow"},
            {"UQRSHRNB", "Unsigned saturating rounding shift right narrow by immediate"},
            {"UQRSHRNT", "Unsigned saturating rounding shift right narrow by immediate"},
            {"UQSHL", "Unsigned saturating shift left"},
            {"UQSHLR", "Unsigned saturating shift left reversed"},
            {"UQSHRN", "Unsigned saturating shift right narrow"},
            {"UQSHRN2", "Unsigned saturating shift right narrow"},
            {"UQSHRNB", "Unsigned saturating shift right narrow by immediate"},
            {"UQSHRNT", "Unsigned saturating shift right narrow by immediate"},
            {"UQSUB", "Unsigned saturating subtract"},
            {"UQSUBR", "Unsigned saturating subtract reversed"},
            {"UQXTN", "Unsigned saturating extract narrow"},
            {"UQXTN2", "Unsigned saturating extract narrow"},
            {"UQXTNB", "Unsigned saturating extract narrow"},
            {"UQXTNT", "Unsigned saturating extract narrow"},
            {"URECPE", "Unsigned reciprocal estimate"},
            {"URHADD", "Unsigned rounding halving add"},
            {"URSHL", "Unsigned rounding shift left"},
            {"URSHLR", "Unsigned rounding shift left reversed"},
            {"URSHR", "Unsigned rounding shift right by immediate"},
            {"URSQRTE", "Unsigned reciprocal square root estimate"},
            {"URSRA", "Unsigned rounding shift right and accumulate"},
            {"USDOT", "Dot product with unsigned and signed integers"},
            {"USHL", "Unsigned shift left"},
            {"USHLL", "Unsigned shift left long"},
            {"USHLL2", "Unsigned shift left long"},
            {"USHLLB", "Unsigned shift left long by immediate"},
            {"USHLLT", "Unsigned shift left long by immediate"},
            {"USHR", "Unsigned shift right"},
            {"USMLALL", "Multi-vector unsigned by signed 8-bit integer multiply-add to 32-bit integer"},
            {"USMMLA", "Unsigned by signed 8-bit integer matrix multiply-accumulate to 32-bit integer"},
            {"USMOP4A", "Unsigned by signed integer quarter-tile sum of outer products, accumulating"},
            {"USMOP4S", "Unsigned by signed integer quarter-tile sum of outer products, subtracting"},
            {"USMOPA", "Unsigned by signed integer sum of outer products, accumulating"},
            {"USMOPS", "Unsigned by signed integer sum of outer products, subtracting"},
            {"USQADD", "Unsigned saturating signed add"},
            {"USRA", "Unsigned shift right and accumulate"},
            {"USTMOPA",
             "Unsigned by signed 8-bit integer sparse sum of outer products to 32-bit integer, accumulating"},
            {"USUBL", "Unsigned subtract long"},
            {"USUBL2", "Unsigned subtract long"},
            {"USUBLB", "Unsigned subtract long"},
            {"USUBLT", "Unsigned subtract long"},
            {"USUBW", "Unsigned subtract wide"},
            {"USUBW2", "Unsigned subtract wide"},
            {"USUBWB", "Unsigned subtract wide"},
            {"USUBWT", "Unsigned subtract wide"},
            {"USVDOT",
             "Multi-vector unsigned by signed 8-bit integer vertical dot product by indexed element to 32-bit integer"},
            {"UTMOPA", "Unsigned 8-bit integer sparse sum of outer products to 32-bit integer, accumulating"},
            {"UUNPK", "Unpack and zero-extend multi-vector elements"},
            {"UUNPKHI", "Unsigned unpack and extend half of vector"},
            {"UUNPKLO", "Unsigned unpack and extend half of vector"},
            {"UVDOT", "Multi-vector unsigned integer vertical dot product by indexed element"},
            {"UXTB", "Unsigned byte / halfword / word extend"},
            {"UXTH", "Unsigned byte / halfword / word extend"},
            {"UXTW", "Unsigned byte / halfword / word extend"},
            {"UZP", "Concatenate elements from two vectors"},
            {"UZP1", "Unzip vectors"},
            {"UZP2", "Unzip vectors"},
            {"UZPQ1", "Concatenate even elements within each pair of quadword vector segments"},
            {"UZPQ2", "Concatenate odd elements within each pair of quadword vector segments"},
            {"WFE", "Wait for event"},
            {"WFET", "Wait for event with timeout"},
            {"WFI", "Wait for interrupt"},
            {"WFIT", "Wait for interrupt with timeout"},
            {"WHILEGE", "While decrementing signed scalar greater than or equal to scalar"},
            {"WHILEGT", "While decrementing signed scalar greater than scalar"},
            {"WHILEHI", "While decrementing unsigned scalar higher than scalar"},
            {"WHILEHS", "While decrementing unsigned scalar higher than or same as scalar"},
            {"WHILELE", "While incrementing signed scalar less than or equal to scalar"},
            {"WHILELO", "While incrementing unsigned scalar lower than scalar"},
            {"WHILELS", "While incrementing unsigned scalar lower than or same as scalar"},
            {"WHILELT", "While incrementing signed scalar less than scalar"},
            {"WHILERW", "While free of read-after-write conflicts"},
            {"WHILEWR", "While free of write-after-read/write conflicts"},
            {"WRFFR", "Write the first-fault register"},
            {"XAFLAG", "Convert floating-point condition flags from external format to Arm format"},
            {"XAR", "Bitwise exclusive-OR and rotate right by immediate"},
            {"XPACD", "Strip Pointer Authentication Code"},
            {"XPACI", "Strip Pointer Authentication Code"},
            {"XPACLRI", "Strip Pointer Authentication Code"},
            {"XTN", "Extract narrow"},
            {"XTN2", "Extract narrow"},
            {"YIELD", "Yield"},
            {"ZERO", "Zero ZT0"},
            {"ZIP", "Interleave elements from two vectors"},
            {"ZIP1", "Zip vectors"},
            {"ZIP2", "Zip vectors"},
            {"ZIPQ1", "Interleave elements from low halves of each pair of quadword vector segments"},
            {"ZIPQ2", "Interleave elements from high halves of each pair of quadword vector segments"}};

    inline const std::flat_map<std::string, std::string> X86{
            {"ADC", "Add with Carry"},
            {"ADD", "Add"},
            {"ADDPD", "Add Packed Double-FP Values"},
            {"ADDPS", "Add Packed Single-FP Values"},
            {"ADDSD", "Add Scalar Double-FP Values"},
            {"ADDSS", "Add Scalar Single-FP Values"},
            {"ADDSUBPD", "Packed Double-FP Add/Subtract"},
            {"ADDSUBPS", "Packed Single-FP Add/Subtract"},
            {"AND", "Logical AND"},
            {"ANDNPD", "Bitwise Logical AND NOT of Packed Double-FP Values"},
            {"ANDNPS", "Bitwise Logical AND NOT of Packed Single-FP Values"},
            {"ANDPD", "Bitwise Logical AND of Packed Double-FP Values"},
            {"ANDPS", "Bitwise Logical AND of Packed Single-FP Values"},
            {"BLENDPD", "Blend Packed Double-FP Values"},
            {"BLENDPS", "Blend Packed Single-FP Values"},
            {"BSF", "Bit Scan Forward"},
            {"BSR", "Bit Scan Reverse"},
            {"BSWAP", "Byte Swap"},
            {"BT", "Bit Test"},
            {"BTC", "Bit Test and Complement"},
            {"BTR", "Bit Test and Reset"},
            {"BTS", "Bit Test and Set"},
            {"CALL", "Call Procedure"},
            {"CALLF", "Call Procedure"},
            {"CBW", "Convert"},
            {"CLC", "Clear Carry Flag"},
            {"CLD", "Clear Direction Flag"},
            {"CLFLUSH", "Flush Cache Line"},
            {"CLI", "Clear Interrupt Flag"},
            {"CLTS", "Clear Task-Switched Flag in CR0"},
            {"CMC", "Complement Carry Flag"},
            {"CMOVB", "Conditional Move - below/not above or equal/carry (CF=1)"},
            {"CMOVBE", "Conditional Move - below or equal/not above (CF=1 OR ZF=1)"},
            {"CMOVL", "Conditional Move - less/not greater (SF!=OF)"},
            {"CMOVLE", "Conditional Move - less or equal/not greater ((ZF=1) OR (SF!=OF))"},
            {"CMOVNB", "Conditional Move - not below/above or equal/not carry (CF=0)"},
            {"CMOVNBE", "Conditional Move - not below or equal/above (CF=0 AND ZF=0)"},
            {"CMOVNL", "Conditional Move - not less/greater or equal (SF=OF)"},
            {"CMOVNLE", "Conditional Move - not less nor equal/greater ((ZF=0) AND (SF=OF))"},
            {"CMOVNO", "Conditional Move - not overflow (OF=0)"},
            {"CMOVNP", "Conditional Move - not parity/parity odd (PF=0)"},
            {"CMOVNS", "Conditional Move - not sign (SF=0)"},
            {"CMOVNZ", "Conditional Move - not zero/not equal (ZF=0)"},
            {"CMOVO", "Conditional Move - overflow (OF=1)"},
            {"CMOVP", "Conditional Move - parity/parity even (PF=1)"},
            {"CMOVS", "Conditional Move - sign (SF=1)"},
            {"CMOVZ", "Conditional Move - zero/equal (ZF=1)"},
            {"CMP", "Compare Two Operands"},
            {"CMPPD", "Compare Packed Double-FP Values"},
            {"CMPPS", "Compare Packed Single-FP Values"},
            {"CMPS", "Compare String Operands"},
            {"CMPSD", "Compare Scalar Double-FP Values"},
            {"CMPSS", "Compare Scalar Single-FP Values"},
            {"CMPXCHG", "Compare and Exchange"},
            {"CMPXCHG8B", "Compare and Exchange Bytes"},
            {"COMISD", "Compare Scalar Ordered Double-FP Values and Set EFLAGS"},
            {"COMISS", "Compare Scalar Ordered Single-FP Values and Set EFLAGS"},
            {"CPUID", "CPU Identification"},
            {"CRC32", "Accumulate CRC32 Value"},
            {"CVTDQ2PD", "Convert Packed DW Integers to Double-FP Values"},
            {"CVTDQ2PS", "Convert Packed DW Integers to Single-FP Values"},
            {"CVTPD2DQ", "Convert Packed Double-FP Values to DW Integers"},
            {"CVTPD2PI", "Convert Packed Double-FP Values to DW Integers"},
            {"CVTPD2PS", "Convert Packed Double-FP Values to Single-FP Values"},
            {"CVTPI2PD", "Convert Packed DW Integers to Double-FP Values"},
            {"CVTPI2PS", "Convert Packed DW Integers to Single-FP Values"},
            {"CVTPS2DQ", "Convert Packed Single-FP Values to DW Integers"},
            {"CVTPS2PD", "Convert Packed Single-FP Values to Double-FP Values"},
            {"CVTPS2PI", "Convert Packed Single-FP Values to DW Integers"},
            {"CVTSD2SI", "Convert Scalar Double-FP Value to DW Integer"},
            {"CVTSD2SS", "Convert Scalar Double-FP Value to Scalar Single-FP Value"},
            {"CVTSI2SD", "Convert DW Integer to Scalar Double-FP Value"},
            {"CVTSI2SS", "Convert DW Integer to Scalar Single-FP Value"},
            {"CVTSS2SD", "Convert Scalar Single-FP Value to Scalar Double-FP Value"},
            {"CVTSS2SI", "Convert Scalar Single-FP Value to DW Integer"},
            {"CVTTPD2DQ", "Convert with Trunc. Packed Double-FP Values to DW Integers"},
            {"CVTTPD2PI", "Convert with Trunc. Packed Double-FP Values to DW Integers"},
            {"CVTTPS2DQ", "Convert with Trunc. Packed Single-FP Values to DW Integers"},
            {"CVTTPS2PI", "Convert with Trunc. Packed Single-FP Values to DW Integers"},
            {"CVTTSD2SI", "Conv. with Trunc. Scalar Double-FP Value to Signed DW Int"},
            {"CVTTSS2SI", "Convert with Trunc. Scalar Single-FP Value to DW Integer"},
            {"CWD", "Convert"},
            {"DEC", "Decrement by 1"},
            {"DIV", "Unsigned Divide"},
            {"DIVPD", "Divide Packed Double-FP Values"},
            {"DIVPS", "Divide Packed Single-FP Values"},
            {"DIVSD", "Divide Scalar Double-FP Values"},
            {"DIVSS", "Divide Scalar Single-FP Values"},
            {"DPPD", "Dot Product of Packed Double-FP Values"},
            {"DPPS", "Dot Product of Packed Single-FP Values"},
            {"EMMS", "Empty MMX Technology State"},
            {"ENTER", "Make Stack Frame for Procedure Parameters"},
            {"EXTRACTPS", "Extract Packed Single-FP Value"},
            {"F2XM1", "Compute 2x-1"},
            {"FABS", "Absolute Value"},
            {"FADD", "Add"},
            {"FADDP", "Add and Pop"},
            {"FBLD", "Load Binary Coded Decimal"},
            {"FBSTP", "Store BCD Integer and Pop"},
            {"FCHS", "Change Sign"},
            {"FCLEX", "Clear Exceptions"},
            {"FCMOVB", "FP Conditional Move - below (CF=1)"},
            {"FCMOVBE", "FP Conditional Move - below or equal (CF=1 or ZF=1)"},
            {"FCMOVE", "FP Conditional Move - equal (ZF=1)"},
            {"FCMOVNB", "FP Conditional Move - not below (CF=0)"},
            {"FCMOVNBE", "FP Conditional Move - below or equal (CF=0 and ZF=0)"},
            {"FCMOVNE", "FP Conditional Move - not equal (ZF=0)"},
            {"FCMOVNU", "FP Conditional Move - not unordered (PF=0)"},
            {"FCMOVU", "FP Conditional Move - unordered (PF=1)"},
            {"FCOM", "Compare Real"},
            {"FCOM2", "Compare Real"},
            {"FCOMI", "Compare Floating Point Values and Set EFLAGS"},
            {"FCOMIP", "Compare Floating Point Values and Set EFLAGS and Pop"},
            {"FCOMP", "Compare Real and Pop"},
            {"FCOMP3", "Compare Real and Pop"},
            {"FCOMP5", "Compare Real and Pop"},
            {"FCOMPP", "Compare Real and Pop Twice"},
            {"FCOS", "Cosine"},
            {"FDECSTP", "Decrement Stack-Top Pointer"},
            {"FDIV", "Divide"},
            {"FDIVP", "Divide and Pop"},
            {"FDIVR", "Reverse Divide"},
            {"FDIVRP", "Reverse Divide and Pop"},
            {"FFREE", "Free Floating-Point Register"},
            {"FFREEP", "Free Floating-Point Register and Pop"},
            {"FIADD", "Add"},
            {"FICOM", "Compare Integer"},
            {"FICOMP", "Compare Integer and Pop"},
            {"FIDIV", "Divide"},
            {"FIDIVR", "Reverse Divide"},
            {"FILD", "Load Integer"},
            {"FIMUL", "Multiply"},
            {"FINCSTP", "Increment Stack-Top Pointer"},
            {"FINIT", "Initialize Floating-Point Unit"},
            {"FIST", "Store Integer"},
            {"FISTP", "Store Integer and Pop"},
            {"FISTTP", "Store Integer with Truncation and Pop"},
            {"FISUB", "Subtract"},
            {"FISUBR", "Reverse Subtract"},
            {"FLD", "Load Floating Point Value"},
            {"FLD1", "Load Constant +1.0"},
            {"FLDCW", "Load x87 FPU Control Word"},
            {"FLDENV", "Load x87 FPU Environment"},
            {"FLDL2E", "Load Constant log2e"},
            {"FLDL2T", "Load Constant log210"},
            {"FLDLG2", "Load Constant log102"},
            {"FLDLN2", "Load Constant loge2"},
            {"FLDPI", "Load Constant "},
            {"FLDZ", "Load Constant +0.0"},
            {"FMUL", "Multiply"},
            {"FMULP", "Multiply and Pop"},
            {"FNCLEX", "Clear Exceptions"},
            {"FNDISI", "nop,Treated as Integer NOP"},
            {"FNENI", "nop,Treated as Integer NOP"},
            {"FNINIT", "Initialize Floating-Point Unit"},
            {"FNOP", "No Operation"},
            {"FNSAVE", "Store x87 FPU State"},
            {"FNSETPM", "nop,Treated as Integer NOP"},
            {"FNSTCW", "Store x87 FPU Control Word"},
            {"FNSTENV", "Store x87 FPU Environment"},
            {"FNSTSW", "Store x87 FPU Status Word"},
            {"FPATAN", "Partial Arctangent and Pop"},
            {"FPREM", "Partial Remainder (for compatibility with i8087 and i287)"},
            {"FPREM1", "IEEE Partial Remainder"},
            {"FPTAN", "Partial Tangent"},
            {"FRNDINT", "Round to Integer"},
            {"FRSTOR", "Restore x87 FPU State"},
            {"FS", "FS segment override prefix"},
            {"FSAVE", "Store x87 FPU State"},
            {"FSCALE", "Scale"},
            {"FSIN", "Sine"},
            {"FSINCOS", "Sine and Cosine"},
            {"FSQRT", "Square Root"},
            {"FST", "Store Floating Point Value"},
            {"FSTCW", "Store x87 FPU Control Word"},
            {"FSTENV", "Store x87 FPU Environment"},
            {"FSTP", "Store Floating Point Value and Pop"},
            {"FSTP1", "part alias5,Store Floating Point Value and Pop"},
            {"FSTP8", "Store Floating Point Value and Pop"},
            {"FSTP9", "Store Floating Point Value and Pop"},
            {"FSTSW", "Store x87 FPU Status Word"},
            {"FSUB", "Subtract"},
            {"FSUBP", "Subtract and Pop"},
            {"FSUBR", "Reverse Subtract"},
            {"FSUBRP", "Reverse Subtract and Pop"},
            {"FTST", "Test"},
            {"FUCOM", "Unordered Compare Floating Point Values"},
            {"FUCOMI", "Unordered Compare Floating Point Values and Set EFLAGS"},
            {"FUCOMIP", "Unordered Compare Floating Point Values and Set EFLAGS and Pop"},
            {"FUCOMP", "Unordered Compare Floating Point Values and Pop"},
            {"FUCOMPP", "Unordered Compare Floating Point Values and Pop Twice"},
            {"FWAIT", "Check pending unmasked floating-point exceptions"},
            {"FXAM", "Examine"},
            {"FXCH", "Exchange Register Contents"},
            {"FXCH4", "Exchange Register Contents"},
            {"FXCH7", "Exchange Register Contents"},
            {"FXRSTOR", "Restore x87 FPU, MMX, XMM, and MXCSR State"},
            {"FXSAVE", "Save x87 FPU, MMX, XMM, and MXCSR State"},
            {"FXTRACT", "Extract Exponent and Significand"},
            {"FYL2X", "Compute y  log2x and Pop"},
            {"FYL2XP1", "Compute y  log2(x+1) and Pop"},
            {"GETSEC", "GETSEC Leaf Functions"},
            {"GS", "GS segment override prefix"},
            {"HADDPD", "Packed Double-FP Horizontal Add"},
            {"HADDPS", "Packed Single-FP Horizontal Add"},
            {"HINT_NOP", "Hintable NOP"},
            {"HLT", "Halt"},
            {"HSUBPD", "Packed Double-FP Horizontal Subtract"},
            {"HSUBPS", "Packed Single-FP Horizontal Subtract"},
            {"IDIV", "Signed Divide"},
            {"IMUL", "Signed Multiply"},
            {"IN", "Input from Port"},
            {"INC", "Increment by 1"},
            {"INS", "Input from Port to String"},
            {"INB", "Input from Port to String"},
            {"INW", "Input from Port to String"},
            {"IND", "Input from Port to String"},
            {"INSERTPS", "Insert Packed Single-FP Value"},
            {"INT", "Call to Interrupt Procedure"},
            {"INT1", "Call to Interrupt Procedure"},
            {"INTO", "Call to Interrupt Procedure"},
            {"INVD", "Invalidate Internal Caches"},
            {"INVEPT", "Invalidate Translations Derived from EPT"},
            {"INVLPG", "Invalidate TLB Entry"},
            {"INVVPID", "Invalidate Translations Based on VPID"},
            {"IRET", "Interrupt Return"},
            {"IRED", "Interrupt Return"},
            {"IREQ", "Interrupt Return"},
            {"JB", "Jump short if below/not above or equal/carry (CF=1)"},
            {"JBE", "Jump short if below or equal/not above (CF=1 OR ZF=1)"},
            {"JECXZ", "Jump short if rCX register is 0"},
            {"JL", "Jump short if less/not greater (SF!=OF)"},
            {"JLE", "Jump short if less or equal/not greater ((ZF=1) OR (SF!=OF))"},
            {"JMP", "Jump"},
            {"JMPE", "Jump to IA-64 Instruction Set"},
            {"JMPF", "Jump"},
            {"JNB", "Jump short if not below/above or equal/not carry (CF=0)"},
            {"JNBE", "Jump short if not below or equal/above (CF=0 AND ZF=0)"},
            {"JNL", "Jump short if not less/greater or equal (SF=OF)"},
            {"JNLE", "Jump short if not less nor equal/greater ((ZF=0) AND (SF=OF))"},
            {"JNO", "Jump short if not overflow (OF=0)"},
            {"JNP", "Jump short if not parity/parity odd (PF=0)"},
            {"JNS", "Jump short if not sign (SF=0)"},
            {"JNZ", "Jump short if not zero/not equal (ZF=0)"},
            {"JO", "Jump short if overflow (OF=1)"},
            {"JP", "Jump short if parity/parity even (PF=1)"},
            {"JS", "Jump short if sign (SF=1)"},
            {"JZ", "Jump short if zero/equal (ZF=1)"},
            {"LAHF", "Load Status Flags into AH Register"},
            {"LAR", "Load Access Rights Byte"},
            {"LDDQU", "Load Unaligned Integer 128 Bits"},
            {"LDMXCSR", "Load MXCSR Register"},
            {"LEA", "Load Effective Address"},
            {"LEAVE", "High Level Procedure Exit"},
            {"LFENCE", "Load Fence"},
            {"LFS", "Load Far Pointer"},
            {"LGDT", "Load Global Descriptor Table Register"},
            {"LGS", "Load Far Pointer"},
            {"LIDT", "Load Interrupt Descriptor Table Register"},
            {"LLDT", "Load Local Descriptor Table Register"},
            {"LMSW", "Load Machine Status Word"},
            {"LOCK", "Assert LOCK# Signal Prefix"},
            {"LODS", "Load String"},
            {"LODQ", "Load String"},
            {"LODD", "Load String"},
            {"LODW", "Load String"},
            {"LODB", "Load String"},
            {"LOOP", "Decrement count; Jump short if count!=0"},
            {"LOOPNZ", "Decrement count; Jump short if count!=0 and ZF=0"},
            {"LOOPZ", "Decrement count; Jump short if count!=0 and ZF=1"},
            {"LSL", "Load Segment Limit"},
            {"LSS", "Load Far Pointer"},
            {"LTR", "Load Task Register"},
            {"MASKMOVDQU", "Store Selected Bytes of Double Quadword"},
            {"MASKMOVQ", "Store Selected Bytes of Quadword"},
            {"MAXPD", "Return Maximum Packed Double-FP Values"},
            {"MAXPS", "Return Maximum Packed Single-FP Values"},
            {"MAXSD", "Return Maximum Scalar Double-FP Value"},
            {"MAXSS", "Return Maximum Scalar Single-FP Value"},
            {"MFENCE", "Memory Fence"},
            {"MINPD", "Return Minimum Packed Double-FP Values"},
            {"MINPS", "Return Minimum Packed Single-FP Values"},
            {"MINSD", "Return Minimum Scalar Double-FP Value"},
            {"MINSS", "Return Minimum Scalar Single-FP Value"},
            {"MONITOR", "Set Up Monitor Address"},
            {"MOV", "Move"},
            {"MOVAPD", "Move Aligned Packed Double-FP Values"},
            {"MOVAPS", "Move Aligned Packed Single-FP Values"},
            {"MOVBE", "Move Data After Swapping Bytes"},
            {"MOVD", "Move Doubleword/Quadword"},
            {"MOVDDUP", "Move One Double-FP and Duplicate"},
            {"MOVDQ2Q", "Move Quadword from XMM to MMX Technology Register"},
            {"MOVDQA", "Move Aligned Double Quadword"},
            {"MOVDQU", "Move Unaligned Double Quadword"},
            {"MOVHLPS", "Move Packed Single-FP Values High to Low"},
            {"MOVHPD", "Move High Packed Double-FP Value"},
            {"MOVHPS", "Move High Packed Single-FP Values"},
            {"MOVLHPS", "Move Packed Single-FP Values Low to High"},
            {"MOVLPD", "Move Low Packed Double-FP Value"},
            {"MOVLPS", "Move Low Packed Single-FP Values"},
            {"MOVMSKPD", "Extract Packed Double-FP Sign Mask"},
            {"MOVMSKPS", "Extract Packed Single-FP Sign Mask"},
            {"MOVNTDQ", "Store Double Quadword Using Non-Temporal Hint"},
            {"MOVNTI", "Store Doubleword Using Non-Temporal Hint"},
            {"MOVNTPD", "Store Packed Double-FP Values Using Non-Temporal Hint"},
            {"MOVNTPS", "Store Packed Single-FP Values Using Non-Temporal Hint"},
            {"MOVNTQ", "Store of Quadword Using Non-Temporal Hint"},
            {"MOVQ", "Move Quadword"},
            {"MOVQ2DQ", "Move Quadword from MMX Technology to XMM Register"},
            {"MOVS", "Move Data from String to String"},
            {"MOVSB", "Move Data from String to String"},
            {"MOVSD", "Move Scalar Double-FP Value"},
            {"MOVSHDUP", "Move Packed Single-FP High and Duplicate"},
            {"MOVSLDUP", "Move Packed Single-FP Low and Duplicate"},
            {"MOVSS", "Move Scalar Single-FP Values"},
            {"MOVSX", "Move with Sign-Extension"},
            {"MOVSXD", "Move with Sign-Extension"},
            {"MOVUPD", "Move Unaligned Packed Double-FP Value"},
            {"MOVUPS", "Move Unaligned Packed Single-FP Values"},
            {"MOVZX", "Move with Zero-Extend"},
            {"MPSADBW", "Compute Multiple Packed Sums of Absolute Difference"},
            {"MUL", "Unsigned Multiply"},
            {"MULPD", "Multiply Packed Double-FP Values"},
            {"MULPS", "Multiply Packed Single-FP Values"},
            {"MULSD", "Multiply Scalar Double-FP Values"},
            {"MULSS", "Multiply Scalar Single-FP Value"},
            {"MWAIT", "Monitor Wait"},
            {"NEG", "Two's Complement Negation"},
            {"NOP", "No Operation"},
            {"NOT", "One's Complement Negation"},
            {"OR", "Logical Inclusive OR"},
            {"ORPD", "Bitwise Logical OR of Double-FP Values"},
            {"ORPS", "Bitwise Logical OR of Single-FP Values"},
            {"OUT", "Output to Port"},
            {"OUTS", "Output String to Port"},
            {"OUTSB", "Output String to Port"},
            {"OUTSW", "Output String to Port"},
            {"PACKSSDW", "Pack with Signed Saturation"},
            {"PACKSSWB", "Pack with Signed Saturation"},
            {"PACKUSWB", "Pack with Unsigned Saturation"},
            {"PADDB", "Add Packed Integers"},
            {"PADDD", "Add Packed Integers"},
            {"PADDQ", "Add Packed Quadword Integers"},
            {"PADDSB", "Add Packed Signed Integers with Signed Saturation"},
            {"PADDSW", "Add Packed Signed Integers with Signed Saturation"},
            {"PADDUSB", "Add Packed Unsigned Integers with Unsigned Saturation"},
            {"PADDUSW", "Add Packed Unsigned Integers with Unsigned Saturation"},
            {"PADDW", "Add Packed Integers"},
            {"PALIGNR", "Packed Align Right"},
            {"PAND", "Logical AND"},
            {"PANDN", "Logical AND NOT"},
            {"PAUSE", "Spin Loop Hint"},
            {"PAVGB", "Average Packed Integers"},
            {"PAVGW", "Average Packed Integers"},
            {"PBLENDW", "Blend Packed Words"},
            {"PCMPEQB", "Compare Packed Data for Equal"},
            {"PCMPEQD", "Compare Packed Data for Equal"},
            {"PCMPEQW", "Compare Packed Data for Equal"},
            {"PCMPESTRI", "Packed Compare Explicit Length Strings, Return Index"},
            {"PCMPESTRM", "Packed Compare Explicit Length Strings, Return Mask"},
            {"PCMPGTB", "Compare Packed Signed Integers for Greater Than"},
            {"PCMPGTD", "Compare Packed Signed Integers for Greater Than"},
            {"PCMPGTW", "Compare Packed Signed Integers for Greater Than"},
            {"PCMPISTRI", "Packed Compare Implicit Length Strings, Return Index"},
            {"PCMPISTRM", "Packed Compare Implicit Length Strings, Return Mask"},
            {"PEXTRB", "Extract Byte"},
            {"PEXTRD", "Extract Dword/Qword"},
            {"PEXTRW", "Extract Word"},
            {"PINSRB", "Insert Byte"},
            {"PINSRD", "Insert Dword/Qword"},
            {"PINSRW", "Insert Word"},
            {"PMADDWD", "Multiply and Add Packed Integers"},
            {"PMAXSW", "Maximum of Packed Signed Word Integers"},
            {"PMAXUB", "Maximum of Packed Unsigned Byte Integers"},
            {"PMINSW", "Minimum of Packed Signed Word Integers"},
            {"PMINUB", "Minimum of Packed Unsigned Byte Integers"},
            {"PMOVMSKB", "Move Byte Mask"},
            {"PMULHUW", "Multiply Packed Unsigned Integers and Store High Result"},
            {"PMULHW", "Multiply Packed Signed Integers and Store High Result"},
            {"PMULLW", "Multiply Packed Signed Integers and Store Low Result"},
            {"PMULUDQ", "Multiply Packed Unsigned DW Integers"},
            {"POP", "Pop a Value from the Stack"},
            {"POPCNT", "Bit Population Count"},
            {"POPF", "Pop Stack into rFLAGS Register"},
            {"POPFQ", "Pop Stack into rFLAGS Register"},
            {"POR", "Bitwise Logical OR"},
            {"PREFETCHNTA", "Prefetch Data Into Caches"},
            {"PREFETCHT0", "Prefetch Data Into Caches"},
            {"PREFETCHT1", "Prefetch Data Into Caches"},
            {"PREFETCHT2", "Prefetch Data Into Caches"},
            {"PSADBW", "Compute Sum of Absolute Differences"},
            {"PSHUFD", "Shuffle Packed Doublewords"},
            {"PSHUFHW", "Shuffle Packed High Words"},
            {"PSHUFLW", "Shuffle Packed Low Words"},
            {"PSHUFW", "Shuffle Packed Words"},
            {"PSLLD", "Shift Packed Data Left Logical"},
            {"PSLLDQ", "Shift Double Quadword Left Logical"},
            {"PSLLQ", "Shift Packed Data Left Logical"},
            {"PSLLW", "Shift Packed Data Left Logical"},
            {"PSRAD", "Shift Packed Data Right Arithmetic"},
            {"PSRAW", "Shift Packed Data Right Arithmetic"},
            {"PSRLD", "Shift Double Quadword Right Logical"},
            {"PSRLDQ", "Shift Double Quadword Right Logical"},
            {"PSRLQ", "Shift Packed Data Right Logical"},
            {"PSRLW", "Shift Packed Data Right Logical"},
            {"PSUBB", "Subtract Packed Integers"},
            {"PSUBD", "Subtract Packed Integers"},
            {"PSUBQ", "Subtract Packed Quadword Integers"},
            {"PSUBSB", "Subtract Packed Signed Integers with Signed Saturation"},
            {"PSUBSW", "Subtract Packed Signed Integers with Signed Saturation"},
            {"PSUBUSB", "Subtract Packed Unsigned Integers with Unsigned Saturation"},
            {"PSUBUSW", "Subtract Packed Unsigned Integers with Unsigned Saturation"},
            {"PSUBW", "Subtract Packed Integers"},
            {"PUNPCKHBW", "Unpack High Data"},
            {"PUNPCKHDQ", "Unpack High Data"},
            {"PUNPCKHQDQ", "Unpack High Data"},
            {"PUNPCKHWD", "Unpack High Data"},
            {"PUNPCKLBW", "Unpack Low Data"},
            {"PUNPCKLDQ", "Unpack Low Data"},
            {"PUNPCKLQDQ", "Unpack Low Data"},
            {"PUNPCKLWD", "Unpack Low Data"},
            {"PUSH", "Push Word, Doubleword or Quadword Onto the Stack"},
            {"PUSHF", "Push rFLAGS Register onto the Stack"},
            {"PUSHFQ", "Push rFLAGS Register onto the Stack"},
            {"PXOR", "Logical Exclusive OR"},
            {"RCL", "Rotate"},
            {"RCPPS", "Compute Reciprocals of Packed Single-FP Values"},
            {"RCPSS", "Compute Reciprocal of Scalar Single-FP Values"},
            {"RCR", "Rotate"},
            {"RDMSR", "Read from Model Specific Register"},
            {"RDPMC", "Read Performance-Monitoring Counters"},
            {"RDTSC", "Read Time-Stamp Counter"},
            {"RDTSCP", "Read Time-Stamp Counter and Processor ID"},
            {"REP", "Repeat String Operation Prefix"},
            {"REPNZ", "Repeat String Operation Prefix"},
            {"REPZ", "Repeat String Operation Prefix"},
            {"RETF", "Return from procedure"},
            {"RETN", "Return from procedure"},
            {"REX", "Access to new 8-bit registers"},
            {"REXB", "Extension of r/m field, base field, or opcode reg field"},
            {"REXR", "Extension of ModR/M reg field"},
            {"REXRB", "REX.R and REX.B combination"},
            {"REXRX", "REX.R and REX.X combination"},
            {"REXRXB", "REX.R, REX.X and REX.B combination"},
            {"REXW", "64 Bit Operand Size"},
            {"REXWB", "REX.W and REX.B combination"},
            {"REXWR", "REX.W and REX.R combination"},
            {"REXWRB", "REX.W, REX.R and REX.B combination"},
            {"REXWRX", "REX.W, REX.R and REX.X combination"},
            {"REXWRXB", "REX.W, REX.R, REX.X and REX.B combination"},
            {"REXWX", "REX.W and REX.X combination"},
            {"REXWXB", "REX.W, REX.X and REX.B combination"},
            {"REXX", "Extension of SIB index field"},
            {"REXXB", "REX.X and REX.B combination"},
            {"ROL", "Rotate"},
            {"ROR", "Rotate"},
            {"ROUNDPD", "Round Packed Double-FP Values"},
            {"ROUNDPS", "Round Packed Single-FP Values"},
            {"ROUNDSD", "Round Scalar Double-FP Values"},
            {"ROUNDSS", "Round Scalar Single-FP Values"},
            {"RSM", "Resume from System Management Mode"},
            {"RSQRTPS", "Compute Recipr. of Square Roots of Packed Single-FP Values"},
            {"RSQRTSS", "Compute Recipr. of Square Root of Scalar Single-FP Value"},
            {"SAHF", "Store AH into Flags"},
            {"SAL", "Shift"},
            {"SAR", "Shift"},
            {"SBB", "Integer Subtraction with Borrow"},
            {"SCAS", "Scan String"},
            {"SETB", "Set Byte on Condition - below/not above or equal/carry (CF=1)"},
            {"SETBE", "Set Byte on Condition - below or equal/not above (CF=1 OR ZF=1)"},
            {"SETL", "Set Byte on Condition - less/not greater (SF!=OF)"},
            {"SETLE", "Set Byte on Condition - less or equal/not greater ((ZF=1) OR (SF!=OF))"},
            {"SETNB", "Set Byte on Condition - not below/above or equal/not carry (CF=0)"},
            {"SETNBE", "Set Byte on Condition - not below or equal/above (CF=0 AND ZF=0)"},
            {"SETNL", "Set Byte on Condition - not less/greater or equal (SF=OF)"},
            {"SETNLE", "Set Byte on Condition - not less nor equal/greater ((ZF=0) AND (SF=OF))"},
            {"SETNO", "Set Byte on Condition - not overflow (OF=0)"},
            {"SETNP", "Set Byte on Condition - not parity/parity odd (PF=0)"},
            {"SETNS", "Set Byte on Condition - not sign (SF=0)"},
            {"SETNZ", "Set Byte on Condition - not zero/not equal (ZF=0)"},
            {"SETO", "Set Byte on Condition - overflow (OF=1)"},
            {"SETP", "Set Byte on Condition - parity/parity even (PF=1)"},
            {"SETS", "Set Byte on Condition - sign (SF=1)"},
            {"SETZ", "Set Byte on Condition - zero/equal (ZF=1)"},
            {"SFENCE", "Store Fence"},
            {"SGDT", "Store Global Descriptor Table Register"},
            {"SHL", "Shift"},
            {"SHLD", "Double Precision Shift Left"},
            {"SHR", "Shift"},
            {"SHRD", "Double Precision Shift Right"},
            {"SHUFPD", "Shuffle Packed Double-FP Values"},
            {"SHUFPS", "Shuffle Packed Single-FP Values"},
            {"SIDT", "Store Interrupt Descriptor Table Register"},
            {"SLDT", "Store Local Descriptor Table Register"},
            {"SMSW", "Store Machine Status Word"},
            {"SQRTPD", "Compute Square Roots of Packed Double-FP Values"},
            {"SQRTPS", "Compute Square Roots of Packed Single-FP Values"},
            {"SQRTSD", "Compute Square Root of Scalar Double-FP Value"},
            {"SQRTSS", "Compute Square Root of Scalar Single-FP Value"},
            {"STC", "Set Carry Flag"},
            {"STD", "Set Direction Flag"},
            {"STI", "Set Interrupt Flag"},
            {"STMXCSR", "Store MXCSR Register State"},
            {"STOS", "Store String"},
            {"STOSB", "Store String"},
            {"STOSW", "Store String"},
            {"STOSD", "Store String"},
            {"STOSQ", "Store String"},
            {"STR", "Store Task Register"},
            {"SUB", "Subtract"},
            {"SUBPD", "Subtract Packed Double-FP Values"},
            {"SUBPS", "Subtract Packed Single-FP Values"},
            {"SUBSD", "Subtract Scalar Double-FP Values"},
            {"SUBSS", "Subtract Scalar Single-FP Values"},
            {"SWAPGS", "Swap GS Base Register"},
            {"SYSCALL", "Fast System Call"},
            {"SYSENTER", "Fast System Call"},
            {"SYSEXIT", "Fast Return from Fast System Call"},
            {"SYSRET", "Return From Fast System Call"},
            {"TEST", "Logical Compare"},
            {"TEST", "Logical Compare"},
            {"UCOMISD", "Unordered Compare Scalar Double-FP Values and Set EFLAGS"},
            {"UCOMISS", "Unordered Compare Scalar Single-FP Values and Set EFLAGS"},
            {"UD", "Undefined Instruction"},
            {"UD2", "Undefined Instruction"},
            {"UNPCKHPD", "Unpack and Interleave High Packed Double-FP Values"},
            {"UNPCKHPS", "Unpack and Interleave High Packed Single-FP Values"},
            {"UNPCKLPD", "Unpack and Interleave Low Packed Double-FP Values"},
            {"UNPCKLPS", "Unpack and Interleave Low Packed Single-FP Values"},
            {"VERR", "Verify a Segment for Reading"},
            {"VERW", "Verify a Segment for Writing"},
            {"VMCALL", "Call to VM Monitor"},
            {"VMCLEAR", "Clear Virtual-Machine Control Structure"},
            {"VMLAUNCH", "Launch Virtual Machine"},
            {"VMPTRLD", "Load Pointer to Virtual-Machine Control Structure"},
            {"VMPTRST", "Store Pointer to Virtual-Machine Control Structure"},
            {"VMREAD", "Read Field from Virtual-Machine Control Structure"},
            {"VMRESUME", "Resume Virtual Machine"},
            {"VMWRITE", "Write Field to Virtual-Machine Control Structure"},
            {"VMXOFF", "Leave VMX Operation"},
            {"VMXON", "Enter VMX Operation"},
            {"WBINVD", "Write Back and Invalidate Cache"},
            {"WRMSR", "Write to Model Specific Register"},
            {"XADD", "Exchange and Add"},
            {"XCHG", "Exchange Register/Memory with Register"},
            {"XGETBV", "Get Value of Extended Control Register"},
            {"XLAT", "Table Look-up Translation"},
            {"XOR", "Logical Exclusive OR"},
            {"XORPD", "Bitwise Logical XOR for Double-FP Values"},
            {"XORPS", "Bitwise Logical XOR for Single-FP Values"},
            {"XRSTOR", "Restore Processor Extended States"},
            {"XSAVE", "Save Processor Extended States"},
            {"XSETBV", "Set Extended Control Register"}};
}  // namespace sontag::tables
