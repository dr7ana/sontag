#pragma once

#include <flat_map>
#include <string>

namespace sontag::tables {
    inline const std::flat_map<std::string, std::string> ARM{
            {"ADC", "Add with Carry"},
            {"ADD", "Add"},
            {"ADR", "Load program or register-relative address (short range)"},
            {"AESD", "AES single round decryption"},
            {"AESE", "AES single round encryption"},
            {"AESIMC", "AES inverse mix columns"},
            {"AESMC", "AES mix columns"},
            {"AND", "Logical AND"},
            {"ASR", "Arithmetic Shift Right"},
            {"B", "Branch"},
            {"BFC", "Bit Field Clear and Insert"},
            {"BFI", "Bit Field Clear and Insert"},
            {"BIC", "Bit Clear"},
            {"BKPT", "Software breakpoint"},
            {"BL", "Branch with Link"},
            {"BLX", "Branch with Link, change instruction set"},
            {"BLXNS", "Branch with Link, change instruction set, Branch with Link and Exchange (Non-secure)"},
            {"BX", "Branch, change instruction set, Branch and Exchange (Non-secure)"},
            {"BXNS", "Branch, change instruction set, Branch and Exchange (Non-secure)"},
            {"CBNZ", "Compare and Branch if {Non}Zero"},
            {"CBZ", "Compare and Branch if {Non}Zero"},
            {"CDP", "Coprocessor Data Processing operation"},
            {"CDP2", "Coprocessor Data Processing operation"},
            {"CLREX", "Clear Exclusive"},
            {"CLZ", "Count leading zeros"},
            {"CMN", "Compare Negative"},
            {"CMP", "Compare"},
            {"CPS", "Change Processor State"},
            {"CRC32", "CRC32"},
            {"CRC32C", "CRC32C"},
            {"CSDB", "Consumption of Speculative Data Barrier"},
            {"DBG", "Debug"},
            {"DCPS1", "Debug switch to exception level 1"},
            {"DCPS2", "Debug switch to exception level 2"},
            {"DCPS3", "Debug switch to exception level 3"},
            {"DMB", "Data Memory Barrier"},
            {"DSB", "Data Synchronization Barrier"},
            {"EOR", "Exclusive OR"},
            {"ERET", "Exception Return"},
            {"ESB", "Error Synchronization Barrier"},
            {"FLDMDBX", "FLDMX"},
            {"FLDMIAX", "FLDMX"},
            {"FSTMDBX", "FSTMX"},
            {"FSTMIAX", "FSTMX"},
            {"HLT", "Halting breakpoint"},
            {"HVC", "Hypervisor Call"},
            {"ISB", "Instruction Synchronization Barrier"},
            {"IT", "If-Then"},
            {"LDA", "Load-Acquire Register Word, Byte, Halfword"},
            {"LDAB", "Load-Acquire Register Word, Byte, Halfword"},
            {"LDAEX", "Load-Acquire Register Exclusive Word"},
            {"LDAEXB", "Load-Acquire Register Exclusive Byte"},
            {"LDAEXD", "Load-Acquire Register Exclusive Doubleword"},
            {"LDAEXH", "Load-Acquire Register Exclusive Halfword"},
            {"LDAH", "Load-Acquire Register Word, Byte, Halfword"},
            {"LDC", "Load Coprocessor"},
            {"LDC2", "Load Coprocessor"},
            {"LDM", "Load Multiple registers"},
            {"LDR", "Load Register with word"},
            {"LDRB", "Load Register with Byte"},
            {"LDRBT", "Load Register with Byte, user mode"},
            {"LDRD", "Load Registers with two words"},
            {"LDREX", "Load Register Exclusive Word"},
            {"LDREXB", "Load Register Exclusive Byte"},
            {"LDREXD", "Load Register Exclusive Doubleword"},
            {"LDREXH", "Load Register Exclusive Halfword"},
            {"LDRH", "Load Register with Halfword"},
            {"LDRHT", "Load Register with Halfword, user mode"},
            {"LDRSB", "Load Register with Signed Byte"},
            {"LDRSBT", "Load Register with Signed Byte, user mode"},
            {"LDRSH", "Load Register with Signed Halfword"},
            {"LDRSHT", "Load Register with Signed Halfword, user mode"},
            {"LDRT", "Load Register with word, user mode"},
            {"lr", "Exception return, no stack"},
            {"LSL", "Logical Shift Left"},
            {"LSR", "Logical Shift Right"},
            {"MCR", "Move from Register to Coprocessor"},
            {"MCRR", "Move from Registers to Coprocessor"},
            {"MLA", "Multiply Accumulate"},
            {"MLS", "Multiply and Subtract"},
            {"MOV", "Move"},
            {"MOVT", "Move Top"},
            {"MRC", "Move from Coprocessor to Register"},
            {"MRRC", "Move from Coprocessor to Registers"},
            {"MRS", "Move from PSR to Register"},
            {"MSR", "Move from Register to PSR"},
            {"MUL", "Multiply"},
            {"MVN", "Move Not"},
            {"NOP", "No Operation"},
            {"ORN", "Logical OR NOT"},
            {"ORR", "Logical OR"},
            {"PKHBT", "Pack Halfwords"},
            {"PKHTB", "Pack Halfwords"},
            {"PLD", "Preload Data"},
            {"PLDW", "Preload Data with intent to Write"},
            {"PLI", "Preload Instruction"},
            {"POP", "POP registers from stack"},
            {"PUSH", "PUSH registers to stack"},
            {"QADD", "Saturating arithmetic"},
            {"QADD16", "Parallel signed saturating arithmetic"},
            {"QADD8", "Parallel signed saturating arithmetic"},
            {"QASX", "Parallel signed saturating arithmetic"},
            {"QDADD", "Saturating arithmetic"},
            {"QDSUB", "Saturating arithmetic"},
            {"QSAX", "Parallel signed saturating arithmetic"},
            {"QSUB", "Saturating arithmetic"},
            {"QSUB16", "Parallel signed saturating arithmetic"},
            {"QSUB8", "Parallel signed saturating arithmetic"},
            {"RBIT", "Reverse Bits"},
            {"REV", "Reverse byte order"},
            {"REV16", "Reverse byte order"},
            {"REVSH", "Reverse byte order"},
            {"RFE", "Return From Exception"},
            {"ROR", "Rotate Right Register"},
            {"RRX", "Rotate Right with Extend"},
            {"RSB", "Reverse Subtract"},
            {"RSC", "Reverse Subtract with Carry"},
            {"SADD16", "Parallel Signed arithmetic"},
            {"SADD8", "Parallel Signed arithmetic"},
            {"SASX", "Parallel Signed arithmetic"},
            {"SBC", "Subtract with Carry"},
            {"SBFX", "Signed, Unsigned Bit Field eXtract"},
            {"SDIV", "Signed Divide"},
            {"SEL", "Select bytes according to APSR GE flags"},
            {"SETEND", "Set Endianness for memory accesses"},
            {"SETPAN", "Set Privileged Access Never"},
            {"SEV", "Set Event"},
            {"SEVL", "Set Event Locally"},
            {"SG", "Secure Gateway"},
            {"SHA1C", "SHA1 hash update (choose)"},
            {"SHA1H", "SHA1 fixed rotate"},
            {"SHA1M", "SHA1 hash update (majority)"},
            {"SHA1P", "SHA1 hash update (parity)"},
            {"SHA1SU0", "SHA1 schedule update 0"},
            {"SHA1SU1", "SHA1 schedule update 1"},
            {"SHA256H", "SHA256 hash update part 1"},
            {"SHA256H2", "SHA256 hash update part 2"},
            {"SHA256SU0", "SHA256 schedule update 0"},
            {"SHA256SU1", "SHA256 schedule update 1"},
            {"SHADD16", "Parallel Signed Halving arithmetic"},
            {"SHADD8", "Parallel Signed Halving arithmetic"},
            {"SHASX", "Parallel Signed Halving arithmetic"},
            {"SHSAX", "Parallel Signed Halving arithmetic"},
            {"SHSUB16", "Parallel Signed Halving arithmetic"},
            {"SHSUB8", "Parallel Signed Halving arithmetic"},
            {"SMC", "Secure Monitor Call"},
            {"SMLAD", "Dual Signed Multiply Accumulate (32 <= 32 + 16 x 16 + 16 x 16)"},
            {"SMLAL", "Signed Multiply Accumulate (64 <= 64 + 32 x 32)"},
            {"SMLALD", "Dual Signed Multiply Accumulate Long (64 <= 64 + 16 x 16 + 16 x 16)"},
            {"SMLALxy", "Signed Multiply Accumulate (64 <= 64 + 16 x 16)"},
            {"SMLAWy", "Signed Multiply with Accumulate (32 <= 32 x 16 + 32)"},
            {"SMLAxy", "Signed Multiply with Accumulate (32 <= 16 x 16 + 32)"},
            {"SMLSD", "Dual Signed Multiply Subtract Accumulate (32 <= 32 + 16 x 16 - 16 x 16)"},
            {"SMLSLD", "Dual Signed Multiply Subtract Accumulate Long (64 <= 64 + 16 x 16 - 16 x 16)"},
            {"SMMLA", "Signed top word Multiply with Accumulate (32 <= TopWord(32 x 32 + 32))"},
            {"SMMLS", "Signed top word Multiply with Subtract (32 <= TopWord(32 - 32 x 32))"},
            {"SMMUL", "Signed top word Multiply (32 <= TopWord(32 x 32))"},
            {"SMUAD", "Dual Signed Multiply, and Add or Subtract products"},
            {"SMULL", "Signed Multiply (64 <= 32 x 32)"},
            {"SMULWy", "Signed Multiply (32 <= 32 x 16)"},
            {"SMULxy", "Signed Multiply (32 <= 16 x 16)"},
            {"SMUSD", "Dual Signed Multiply, and Add or Subtract products"},
            {"SRS", "Store Return State"},
            {"SSAT", "Signed Saturate"},
            {"SSAT16", "Signed Saturate, parallel halfwords"},
            {"SSAX", "Parallel Signed arithmetic"},
            {"SSUB16", "Parallel Signed arithmetic"},
            {"SSUB8", "Parallel Signed arithmetic"},
            {"STC", "Store Coprocessor"},
            {"STL", "Store-Release Word"},
            {"STLB", "Store-Release Byte"},
            {"STLEX", "Store-Release Exclusive Word"},
            {"STLEXB", "Store-Release Exclusive Byte"},
            {"STLEXD", "Store-Release Exclusive Doubleword"},
            {"STLEXH", "Store-Release Exclusive Halfword"},
            {"STLH", "Store-Release Halfword"},
            {"STM", "Store Multiple registers"},
            {"STR", "Store Register with word"},
            {"STRB", "Store Register with Byte"},
            {"STRBT", "Store Register with Byte, user mode"},
            {"STRD", "Store Registers with two words"},
            {"STREX", "Store Register Exclusive Word"},
            {"STREXB", "Store Register Exclusive Byte"},
            {"STREXD", "Store Register Exclusive Doubleword"},
            {"STREXH", "Store Register Exclusive Halfword"},
            {"STRH", "Store Register with Halfword"},
            {"STRHT", "Store Register with Halfword, user mode"},
            {"STRT", "Store Register with word, user mode"},
            {"SUB", "Subtract"},
            {"SUBS pc", "Exception return, no stack"},
            {"SVC", "(formerly SWI)Supervisor Call"},
            {"SXTAB", "Signed extend, with Addition"},
            {"SXTAB16", "Signed extend, with Addition"},
            {"SXTAH", "Signed extend, with Addition"},
            {"SXTB", "Signed extend"},
            {"SXTB16", "Signed extend"},
            {"SXTH", "Signed extend"},
            {"SYS", "Execute System coprocessor instruction"},
            {"TBB", "Table Branch Byte, Halfword"},
            {"TBH", "Table Branch Byte, Halfword"},
            {"TEQ", "Test Equivalence"},
            {"TST", "Test"},
            {"TT", "Test Target (Alternate Domain, Unprivileged)"},
            {"TTA", "Test Target (Alternate Domain, Unprivileged)"},
            {"TTAT", "Test Target (Alternate Domain, Unprivileged)"},
            {"TTT", "Test Target (Alternate Domain, Unprivileged)"},
            {"UADD16", "Parallel Unsigned arithmetic"},
            {"UADD8", "Parallel Unsigned arithmetic"},
            {"UASX", "Parallel Unsigned arithmetic"},
            {"UBFX", "Signed, Unsigned Bit Field eXtract"},
            {"UDF", "Permanently Undefined"},
            {"UDIV", "Unsigned Divide"},
            {"UHADD16", "Parallel Unsigned Halving arithmetic"},
            {"UHADD8", "Parallel Unsigned Halving arithmetic"},
            {"UHASX", "Parallel Unsigned Halving arithmetic"},
            {"UHSAX", "Parallel Unsigned Halving arithmetic"},
            {"UHSUB16", "Parallel Unsigned Halving arithmetic"},
            {"UHSUB8", "Parallel Unsigned Halving arithmetic"},
            {"UMAAL", "Unsigned Multiply Accumulate Accumulate Long (64 <= 32 + 32 + 32 x 32)"},
            {"UMLAL", "Unsigned Multiply Accumulate (64 <= 32 x 32 + 64), Unsigned Multiply (64 <= 32 x 32)"},
            {"UMULL", "Unsigned Multiply Accumulate (64 <= 32 x 32 + 64), Unsigned Multiply (64 <= 32 x 32)"},
            {"UQADD16", "Parallel Unsigned Saturating arithmetic"},
            {"UQADD8", "Parallel Unsigned Saturating arithmetic"},
            {"UQASX", "Parallel Unsigned Saturating arithmetic"},
            {"UQSAX", "Parallel Unsigned Saturating arithmetic"},
            {"UQSUB16", "Parallel Unsigned Saturating arithmetic"},
            {"UQSUB8", "Parallel Unsigned Saturating arithmetic"},
            {"USAD8", "Unsigned Sum of Absolute Differences"},
            {"USADA8", "Accumulate Unsigned Sum of Absolute Differences"},
            {"USAT", "Unsigned Saturate"},
            {"USAT16", "Unsigned Saturate, parallel halfwords"},
            {"USAX", "Parallel Unsigned arithmetic"},
            {"USUB16", "Parallel Unsigned arithmetic"},
            {"USUB8", "Parallel Unsigned arithmetic"},
            {"UXTAB", "Unsigned extend with Addition"},
            {"UXTAB16", "Unsigned extend with Addition"},
            {"UXTAH", "Unsigned extend with Addition"},
            {"UXTB", "Unsigned extend"},
            {"UXTB16", "Unsigned extend"},
            {"UXTH", "Unsigned extend"},
            {"VABA", "Absolute difference and Accumulate, Absolute Difference"},
            {"VABD", "Absolute difference and Accumulate, Absolute Difference"},
            {"VABS", "Absolute value"},
            {"VACGE", "Absolute Compare Greater than or Equal, Greater Than"},
            {"VACGT", "Absolute Compare Greater than or Equal, Greater Than"},
            {"VACLE", "Absolute Compare Less than or Equal, Less Than (pseudo-instructions)"},
            {"VACLT", "Absolute Compare Less than or Equal, Less Than (pseudo-instructions)"},
            {"VADD", "Add"},
            {"VADDHN", "Add, select High half"},
            {"VAND", "Bitwise AND"},
            {"VBIC", "Bitwise Bit Clear (register)"},
            {"VBIF", "Bitwise Insert if False, Insert if True, Select"},
            {"VBIT", "Bitwise Insert if False, Insert if True, Select"},
            {"VBSL", "Bitwise Insert if False, Insert if True, Select"},
            {"VCADD", "Vector Complex Add"},
            {"VCEQ", "Compare Equal"},
            {"VCGE", "Compare Greater than or Equal"},
            {"VCGT", "Compare Greater Than"},
            {"VCLE", "Compare Less than or Equal"},
            {"VCLS", "Count Leading Sign bits, Count Leading Zeros, and Count set bits"},
            {"VCLT", "Compare Less Than"},
            {"VCLZ", "Count Leading Sign bits, Count Leading Zeros, and Count set bits"},
            {"VCMLA", "Vector Complex Multiply Accumulate"},
            {"VCMLA", "(by element) Vector Complex Multiply Accumulate (by element)"},
            {"VCMP", "Compare"},
            {"VCMPE", "Compare"},
            {"VCNT", "Count Leading Sign bits, Count Leading Zeros, and Count set bits"},
            {"VCVT", "Convert between SP/DP, FP/I, FP/FP"},
            {"VCVTB", "Convert between half-precision and single-precision floating-point"},
            {"VCVTT", "Convert between half-precision and double-precision"},
            {"VDIV", "Divide"},
            {"VDUP", "Duplicate scalar to all lanes of vector"},
            {"VEOR", "Bitwise Exclusive OR"},
            {"VEXT", "Extract"},
            {"VFMA", "Fused multiply accumulate"},
            {"VFMAL", "Vector Floating-point Multiply-Add Long to accumulator (by scalar)"},
            {"VFMS", "Fused multiply subtract"},
            {"VFMSL", "Vector Floating-point Multiply-Add Long to accumulator (by scalar)"},
            {"VFNMA", "Fused multiply accumulate with negation"},
            {"VFNMS", "Fused multiply subtract with negation"},
            {"VHADD", "Halving Add, Halving Subtract"},
            {"VHSUB", "Halving Add, Halving Subtract"},
            {"VJCVT", "Javascript Convert to signed fixed-point, rounding toward Zero"},
            {"VLD", "Vector Load"},
            {"VLDM", "Extension register load multiple"},
            {"VLDR", "Extension register load"},
            {"VLLDM", "Floating-point Lazy Load Multiple"},
            {"VLSTM", "Floating-point Lazy Store Multiple"},
            {"VMAX", "Maximum, Minimum"},
            {"VMAXNM", "Maximum, Minimum, consistent with IEEE 754-2008"},
            {"VMIN", "Maximum, Minimum"},
            {"VMINNM", "Maximum, Minimum, consistent with IEEE 754-2008"},
            {"VMLA", "Multiply accumulate"},
            {"VMLS", "Multiply subtract"},
            {"VMOV",
             "Insert floating-point immediate in single-precision or double-precision register, or copy one FP "
             "register into another FP register of the same width"},
            {"VMOV{U}N", "Move Long, Move Narrow (register)"},
            {"VMOVL", "Move Long, Move Narrow (register)"},
            {"VMRS", "Transfer contents from a floating-point system register to a general-purpose register"},
            {"VMSR", "Transfer contents from a general-purpose register to a floating-point system register"},
            {"VMUL", "Multiply"},
            {"VMVN", "Move Negative (immediate)"},
            {"VNEG", "Negate"},
            {"VNMLA", "Negated multiply accumulate"},
            {"VNMLS", "Negated multiply subtract"},
            {"VNMUL", "Negated multiply"},
            {"VORN", "Bitwise OR NOT"},
            {"VORR", "Bitwise OR (register)"},
            {"VPADAL", "Pairwise Add and Accumulate"},
            {"VPADD", "Pairwise Add"},
            {"VPMAX", "Pairwise Maximum"},
            {"VPMIN", "Pairwise Minimum"},
            {"VPOP", "Extension register load multiple"},
            {"VPUSH", "Extension register store multiple"},
            {"VQABS", "Absolute value, saturate"},
            {"VQADD", "Add, saturate"},
            {"VQDMLAL", "Saturating Doubling Multiply Accumulate"},
            {"VQDMLSL", "Saturating Doubling Multiply Subtract"},
            {"VQDMULH", "Saturating Doubling Multiply returning High half"},
            {"VQDMULL", "Saturating Doubling Multiply"},
            {"VQMOV{U}N", "Saturating Move (register)"},
            {"VQNEG", "Negate, saturate"},
            {"VQRDMULH", "Saturating Doubling Multiply returning High half"},
            {"VQRSHL", "Shift Left, Round, saturate (by signed variable)"},
            {"VQRSHR{U}N", "Shift Right, Round, saturate (by immediate)"},
            {"VQSHL", "Shift Left, saturate (by immediate)"},
            {"VQSHR{U}N", "Shift Right, saturate (by immediate)"},
            {"VQSUB", "Subtract, saturate"},
            {"VRADDHN", "Add, select High half, Round"},
            {"VRECPE", "Reciprocal Estimate"},
            {"VRECPS", "Reciprocal Step"},
            {"VREV", "Reverse elements"},
            {"VRHADD", "Halving Add, Round"},
            {"VRINT", "Round to integer"},
            {"VRSHR", "Shift Right and Round (by immediate)"},
            {"VRSHRN", "Shift Right, Round, Narrow (by immediate)"},
            {"VRSQRTE", "Reciprocal Square Root Estimate"},
            {"VRSQRTS", "Reciprocal Square Root Step"},
            {"VRSRA", "Shift Right, Round, and Accumulate (by immediate)"},
            {"VRSUBHN", "Subtract, select High half, Round"},
            {"VSDOT", "(by element),Dot Product index form with signed integers"},
            {"VSDOT", "(vector),Dot Product vector form with signed integers"},
            {"VSEL", "Select"},
            {"VSHL", "Shift Left (by immediate)"},
            {"VSHR", "Shift Right (by immediate)"},
            {"VSHRN", "Shift Right, Narrow (by immediate)"},
            {"VSLI", "Shift Left and Insert"},
            {"VSQRT", "Square Root"},
            {"VSRA", "Shift Right, Accumulate (by immediate)"},
            {"VSRI", "Shift Right and Insert"},
            {"VST", "Vector Store"},
            {"VSTM", "Extension register store multiple"},
            {"VSTR", "Extension register store"},
            {"VSUB", "Subtract"},
            {"VSUBHN", "Subtract, select High half"},
            {"VSWP", "Swap vectors"},
            {"VTBL", "Vector table look-up"},
            {"VTBX", "Vector table look-up"},
            {"VTRN", "Vector transpose"},
            {"VTST", "Test bits"},
            {"VUDOT", "(by element),Dot Product index form with unsigned integers"},
            {"VUDOT", "(vector),Dot Product vector form with unsigned integers"},
            {"VUZP", "Vector interleave and de-interleave"},
            {"VZIP", "Vector interleave and de-interleave"},
            {"WFE", "Wait For Event"},
            {"WFI", "Wait For Interrupt"},
            {"YIELD", "Yield"},
    };

    inline const std::flat_map<std::string, std::string> X86{
            {"ADC", "Add with Carry"},
            {"ADD", "Add"},
            {"ADDPD", "Add Packed Double-FP Values"},
            {"ADDPS", "Add Packed Single-FP Values"},
            {"ADDSD", "Add Scalar Double-FP Values"},
            {"ADDSS", "Add Scalar Single-FP Values"},
            {"ADDSUBPD", "Packed Double-FP Add/Subtract"},
            {"ADDSUBPS", "Packed Single-FP Add/Subtract"},
            {"AND", "Logical AND"},
            {"ANDNPD", "Bitwise Logical AND NOT of Packed Double-FP Values"},
            {"ANDNPS", "Bitwise Logical AND NOT of Packed Single-FP Values"},
            {"ANDPD", "Bitwise Logical AND of Packed Double-FP Values"},
            {"ANDPS", "Bitwise Logical AND of Packed Single-FP Values"},
            {"BLENDPD", "Blend Packed Double-FP Values"},
            {"BLENDPS", "Blend Packed Single-FP Values"},
            {"BSF", "Bit Scan Forward"},
            {"BSR", "Bit Scan Reverse"},
            {"BSWAP", "Byte Swap"},
            {"BT", "Bit Test"},
            {"BTC", "Bit Test and Complement"},
            {"BTR", "Bit Test and Reset"},
            {"BTS", "Bit Test and Set"},
            {"CALL", "Call Procedure"},
            {"CALLF", "Call Procedure"},
            {"CBW", "Convert"},
            {"CLC", "Clear Carry Flag"},
            {"CLD", "Clear Direction Flag"},
            {"CLFLUSH", "Flush Cache Line"},
            {"CLI", "Clear Interrupt Flag"},
            {"CLTS", "Clear Task-Switched Flag in CR0"},
            {"CMC", "Complement Carry Flag"},
            {"CMOVB", "Conditional Move - below/not above or equal/carry (CF=1)"},
            {"CMOVBE", "Conditional Move - below or equal/not above (CF=1 OR ZF=1)"},
            {"CMOVL", "Conditional Move - less/not greater (SF!=OF)"},
            {"CMOVLE", "Conditional Move - less or equal/not greater ((ZF=1) OR (SF!=OF))"},
            {"CMOVNB", "Conditional Move - not below/above or equal/not carry (CF=0)"},
            {"CMOVNBE", "Conditional Move - not below or equal/above (CF=0 AND ZF=0)"},
            {"CMOVNL", "Conditional Move - not less/greater or equal (SF=OF)"},
            {"CMOVNLE", "Conditional Move - not less nor equal/greater ((ZF=0) AND (SF=OF))"},
            {"CMOVNO", "Conditional Move - not overflow (OF=0)"},
            {"CMOVNP", "Conditional Move - not parity/parity odd (PF=0)"},
            {"CMOVNS", "Conditional Move - not sign (SF=0)"},
            {"CMOVNZ", "Conditional Move - not zero/not equal (ZF=0)"},
            {"CMOVO", "Conditional Move - overflow (OF=1)"},
            {"CMOVP", "Conditional Move - parity/parity even (PF=1)"},
            {"CMOVS", "Conditional Move - sign (SF=1)"},
            {"CMOVZ", "Conditional Move - zero/equal (ZF=1)"},
            {"CMP", "Compare Two Operands"},
            {"CMPPD", "Compare Packed Double-FP Values"},
            {"CMPPS", "Compare Packed Single-FP Values"},
            {"CMPS", "Compare String Operands"},
            {"CMPSD", "Compare Scalar Double-FP Values"},
            {"CMPSS", "Compare Scalar Single-FP Values"},
            {"CMPXCHG", "Compare and Exchange"},
            {"CMPXCHG8B", "Compare and Exchange Bytes"},
            {"COMISD", "Compare Scalar Ordered Double-FP Values and Set EFLAGS"},
            {"COMISS", "Compare Scalar Ordered Single-FP Values and Set EFLAGS"},
            {"CPUID", "CPU Identification"},
            {"CRC32", "Accumulate CRC32 Value"},
            {"CVTDQ2PD", "Convert Packed DW Integers to Double-FP Values"},
            {"CVTDQ2PS", "Convert Packed DW Integers to Single-FP Values"},
            {"CVTPD2DQ", "Convert Packed Double-FP Values to DW Integers"},
            {"CVTPD2PI", "Convert Packed Double-FP Values to DW Integers"},
            {"CVTPD2PS", "Convert Packed Double-FP Values to Single-FP Values"},
            {"CVTPI2PD", "Convert Packed DW Integers to Double-FP Values"},
            {"CVTPI2PS", "Convert Packed DW Integers to Single-FP Values"},
            {"CVTPS2DQ", "Convert Packed Single-FP Values to DW Integers"},
            {"CVTPS2PD", "Convert Packed Single-FP Values to Double-FP Values"},
            {"CVTPS2PI", "Convert Packed Single-FP Values to DW Integers"},
            {"CVTSD2SI", "Convert Scalar Double-FP Value to DW Integer"},
            {"CVTSD2SS", "Convert Scalar Double-FP Value to Scalar Single-FP Value"},
            {"CVTSI2SD", "Convert DW Integer to Scalar Double-FP Value"},
            {"CVTSI2SS", "Convert DW Integer to Scalar Single-FP Value"},
            {"CVTSS2SD", "Convert Scalar Single-FP Value to Scalar Double-FP Value"},
            {"CVTSS2SI", "Convert Scalar Single-FP Value to DW Integer"},
            {"CVTTPD2DQ", "Convert with Trunc. Packed Double-FP Values to DW Integers"},
            {"CVTTPD2PI", "Convert with Trunc. Packed Double-FP Values to DW Integers"},
            {"CVTTPS2DQ", "Convert with Trunc. Packed Single-FP Values to DW Integers"},
            {"CVTTPS2PI", "Convert with Trunc. Packed Single-FP Values to DW Integers"},
            {"CVTTSD2SI", "Conv. with Trunc. Scalar Double-FP Value to Signed DW Int"},
            {"CVTTSS2SI", "Convert with Trunc. Scalar Single-FP Value to DW Integer"},
            {"CWD", "Convert"},
            {"DEC", "Decrement by 1"},
            {"DIV", "Unsigned Divide"},
            {"DIVPD", "Divide Packed Double-FP Values"},
            {"DIVPS", "Divide Packed Single-FP Values"},
            {"DIVSD", "Divide Scalar Double-FP Values"},
            {"DIVSS", "Divide Scalar Single-FP Values"},
            {"DPPD", "Dot Product of Packed Double-FP Values"},
            {"DPPS", "Dot Product of Packed Single-FP Values"},
            {"EMMS", "Empty MMX Technology State"},
            {"ENTER", "Make Stack Frame for Procedure Parameters"},
            {"EXTRACTPS", "Extract Packed Single-FP Value"},
            {"F2XM1", "Compute 2x-1"},
            {"FABS", "Absolute Value"},
            {"FADD", "Add"},
            {"FADDP", "Add and Pop"},
            {"FBLD", "Load Binary Coded Decimal"},
            {"FBSTP", "Store BCD Integer and Pop"},
            {"FCHS", "Change Sign"},
            {"FCLEX", "Clear Exceptions"},
            {"FCMOVB", "FP Conditional Move - below (CF=1)"},
            {"FCMOVBE", "FP Conditional Move - below or equal (CF=1 or ZF=1)"},
            {"FCMOVE", "FP Conditional Move - equal (ZF=1)"},
            {"FCMOVNB", "FP Conditional Move - not below (CF=0)"},
            {"FCMOVNBE", "FP Conditional Move - below or equal (CF=0 and ZF=0)"},
            {"FCMOVNE", "FP Conditional Move - not equal (ZF=0)"},
            {"FCMOVNU", "FP Conditional Move - not unordered (PF=0)"},
            {"FCMOVU", "FP Conditional Move - unordered (PF=1)"},
            {"FCOM", "Compare Real"},
            {"FCOM2", "Compare Real"},
            {"FCOMI", "Compare Floating Point Values and Set EFLAGS"},
            {"FCOMIP", "Compare Floating Point Values and Set EFLAGS and Pop"},
            {"FCOMP", "Compare Real and Pop"},
            {"FCOMP3", "Compare Real and Pop"},
            {"FCOMP5", "Compare Real and Pop"},
            {"FCOMPP", "Compare Real and Pop Twice"},
            {"FCOS", "Cosine"},
            {"FDECSTP", "Decrement Stack-Top Pointer"},
            {"FDIV", "Divide"},
            {"FDIVP", "Divide and Pop"},
            {"FDIVR", "Reverse Divide"},
            {"FDIVRP", "Reverse Divide and Pop"},
            {"FFREE", "Free Floating-Point Register"},
            {"FFREEP", "Free Floating-Point Register and Pop"},
            {"FIADD", "Add"},
            {"FICOM", "Compare Integer"},
            {"FICOMP", "Compare Integer and Pop"},
            {"FIDIV", "Divide"},
            {"FIDIVR", "Reverse Divide"},
            {"FILD", "Load Integer"},
            {"FIMUL", "Multiply"},
            {"FINCSTP", "Increment Stack-Top Pointer"},
            {"FINIT", "Initialize Floating-Point Unit"},
            {"FIST", "Store Integer"},
            {"FISTP", "Store Integer and Pop"},
            {"FISTTP", "Store Integer with Truncation and Pop"},
            {"FISUB", "Subtract"},
            {"FISUBR", "Reverse Subtract"},
            {"FLD", "Load Floating Point Value"},
            {"FLD1", "Load Constant +1.0"},
            {"FLDCW", "Load x87 FPU Control Word"},
            {"FLDENV", "Load x87 FPU Environment"},
            {"FLDL2E", "Load Constant log2e"},
            {"FLDL2T", "Load Constant log210"},
            {"FLDLG2", "Load Constant log102"},
            {"FLDLN2", "Load Constant loge2"},
            {"FLDPI", "Load Constant π"},
            {"FLDZ", "Load Constant +0.0"},
            {"FMUL", "Multiply"},
            {"FMULP", "Multiply and Pop"},
            {"FNCLEX", "Clear Exceptions"},
            {"FNDISI", "nop,Treated as Integer NOP"},
            {"FNENI", "nop,Treated as Integer NOP"},
            {"FNINIT", "Initialize Floating-Point Unit"},
            {"FNOP", "No Operation"},
            {"FNSAVE", "Store x87 FPU State"},
            {"FNSETPM", "nop,Treated as Integer NOP"},
            {"FNSTCW", "Store x87 FPU Control Word"},
            {"FNSTENV", "Store x87 FPU Environment"},
            {"FNSTSW", "Store x87 FPU Status Word"},
            {"FPATAN", "Partial Arctangent and Pop"},
            {"FPREM", "Partial Remainder (for compatibility with i8087 and i287)"},
            {"FPREM1", "IEEE Partial Remainder"},
            {"FPTAN", "Partial Tangent"},
            {"FRNDINT", "Round to Integer"},
            {"FRSTOR", "Restore x87 FPU State"},
            {"FS", "FS segment override prefix"},
            {"FSAVE", "Store x87 FPU State"},
            {"FSCALE", "Scale"},
            {"FSIN", "Sine"},
            {"FSINCOS", "Sine and Cosine"},
            {"FSQRT", "Square Root"},
            {"FST", "Store Floating Point Value"},
            {"FSTCW", "Store x87 FPU Control Word"},
            {"FSTENV", "Store x87 FPU Environment"},
            {"FSTP", "Store Floating Point Value and Pop"},
            {"FSTP1", "part alias5,Store Floating Point Value and Pop"},
            {"FSTP8", "Store Floating Point Value and Pop"},
            {"FSTP9", "Store Floating Point Value and Pop"},
            {"FSTSW", "Store x87 FPU Status Word"},
            {"FSUB", "Subtract"},
            {"FSUBP", "Subtract and Pop"},
            {"FSUBR", "Reverse Subtract"},
            {"FSUBRP", "Reverse Subtract and Pop"},
            {"FTST", "Test"},
            {"FUCOM", "Unordered Compare Floating Point Values"},
            {"FUCOMI", "Unordered Compare Floating Point Values and Set EFLAGS"},
            {"FUCOMIP", "Unordered Compare Floating Point Values and Set EFLAGS and Pop"},
            {"FUCOMP", "Unordered Compare Floating Point Values and Pop"},
            {"FUCOMPP", "Unordered Compare Floating Point Values and Pop Twice"},
            {"FWAIT", "Check pending unmasked floating-point exceptions"},
            {"FXAM", "Examine"},
            {"FXCH", "Exchange Register Contents"},
            {"FXCH4", "Exchange Register Contents"},
            {"FXCH7", "Exchange Register Contents"},
            {"FXRSTOR", "Restore x87 FPU, MMX, XMM, and MXCSR State"},
            {"FXSAVE", "Save x87 FPU, MMX, XMM, and MXCSR State"},
            {"FXTRACT", "Extract Exponent and Significand"},
            {"FYL2X", "Compute y × log2x and Pop"},
            {"FYL2XP1", "Compute y × log2(x+1) and Pop"},
            {"GETSEC", "GETSEC Leaf Functions"},
            {"GS", "GS segment override prefix"},
            {"HADDPD", "Packed Double-FP Horizontal Add"},
            {"HADDPS", "Packed Single-FP Horizontal Add"},
            {"HINT_NOP", "Hintable NOP"},
            {"HLT", "Halt"},
            {"HSUBPD", "Packed Double-FP Horizontal Subtract"},
            {"HSUBPS", "Packed Single-FP Horizontal Subtract"},
            {"IDIV", "Signed Divide"},
            {"IMUL", "Signed Multiply"},
            {"IN", "Input from Port"},
            {"INC", "Increment by 1"},
            {"INS", "Input from Port to String"},
            {"INB", "Input from Port to String"},
            {"INW", "Input from Port to String"},
            {"IND", "Input from Port to String"},
            {"INSERTPS", "Insert Packed Single-FP Value"},
            {"INT", "Call to Interrupt Procedure"},
            {"INT1", "Call to Interrupt Procedure"},
            {"INTO", "Call to Interrupt Procedure"},
            {"INVD", "Invalidate Internal Caches"},
            {"INVEPT", "Invalidate Translations Derived from EPT"},
            {"INVLPG", "Invalidate TLB Entry"},
            {"INVVPID", "Invalidate Translations Based on VPID"},
            {"IRET", "Interrupt Return"},
            {"IRED", "Interrupt Return"},
            {"IREQ", "Interrupt Return"},
            {"JB", "Jump short if below/not above or equal/carry (CF=1)"},
            {"JBE", "Jump short if below or equal/not above (CF=1 OR ZF=1)"},
            {"JECXZ", "Jump short if rCX register is 0"},
            {"JL", "Jump short if less/not greater (SF!=OF)"},
            {"JLE", "Jump short if less or equal/not greater ((ZF=1) OR (SF!=OF))"},
            {"JMP", "Jump"},
            {"JMPE", "Jump to IA-64 Instruction Set"},
            {"JMPF", "Jump"},
            {"JNB", "Jump short if not below/above or equal/not carry (CF=0)"},
            {"JNBE", "Jump short if not below or equal/above (CF=0 AND ZF=0)"},
            {"JNL", "Jump short if not less/greater or equal (SF=OF)"},
            {"JNLE", "Jump short if not less nor equal/greater ((ZF=0) AND (SF=OF))"},
            {"JNO", "Jump short if not overflow (OF=0)"},
            {"JNP", "Jump short if not parity/parity odd (PF=0)"},
            {"JNS", "Jump short if not sign (SF=0)"},
            {"JNZ", "Jump short if not zero/not equal (ZF=0)"},
            {"JO", "Jump short if overflow (OF=1)"},
            {"JP", "Jump short if parity/parity even (PF=1)"},
            {"JS", "Jump short if sign (SF=1)"},
            {"JZ", "Jump short if zero/equal (ZF=1)"},
            {"LAHF", "Load Status Flags into AH Register"},
            {"LAR", "Load Access Rights Byte"},
            {"LDDQU", "Load Unaligned Integer 128 Bits"},
            {"LDMXCSR", "Load MXCSR Register"},
            {"LEA", "Load Effective Address"},
            {"LEAVE", "High Level Procedure Exit"},
            {"LFENCE", "Load Fence"},
            {"LFS", "Load Far Pointer"},
            {"LGDT", "Load Global Descriptor Table Register"},
            {"LGS", "Load Far Pointer"},
            {"LIDT", "Load Interrupt Descriptor Table Register"},
            {"LLDT", "Load Local Descriptor Table Register"},
            {"LMSW", "Load Machine Status Word"},
            {"LOCK", "Assert LOCK# Signal Prefix"},
            {"LODS", "Load String"},
            {"LODQ", "Load String"},
            {"LODD", "Load String"},
            {"LODW", "Load String"},
            {"LODB", "Load String"},
            {"LOOP", "Decrement count; Jump short if count!=0"},
            {"LOOPNZ", "Decrement count; Jump short if count!=0 and ZF=0"},
            {"LOOPZ", "Decrement count; Jump short if count!=0 and ZF=1"},
            {"LSL", "Load Segment Limit"},
            {"LSS", "Load Far Pointer"},
            {"LTR", "Load Task Register"},
            {"MASKMOVDQU", "Store Selected Bytes of Double Quadword"},
            {"MASKMOVQ", "Store Selected Bytes of Quadword"},
            {"MAXPD", "Return Maximum Packed Double-FP Values"},
            {"MAXPS", "Return Maximum Packed Single-FP Values"},
            {"MAXSD", "Return Maximum Scalar Double-FP Value"},
            {"MAXSS", "Return Maximum Scalar Single-FP Value"},
            {"MFENCE", "Memory Fence"},
            {"MINPD", "Return Minimum Packed Double-FP Values"},
            {"MINPS", "Return Minimum Packed Single-FP Values"},
            {"MINSD", "Return Minimum Scalar Double-FP Value"},
            {"MINSS", "Return Minimum Scalar Single-FP Value"},
            {"MONITOR", "Set Up Monitor Address"},
            {"MOV", "Move"},
            {"MOVAPD", "Move Aligned Packed Double-FP Values"},
            {"MOVAPS", "Move Aligned Packed Single-FP Values"},
            {"MOVBE", "Move Data After Swapping Bytes"},
            {"MOVD", "Move Doubleword/Quadword"},
            {"MOVDDUP", "Move One Double-FP and Duplicate"},
            {"MOVDQ2Q", "Move Quadword from XMM to MMX Technology Register"},
            {"MOVDQA", "Move Aligned Double Quadword"},
            {"MOVDQU", "Move Unaligned Double Quadword"},
            {"MOVHLPS", "Move Packed Single-FP Values High to Low"},
            {"MOVHPD", "Move High Packed Double-FP Value"},
            {"MOVHPS", "Move High Packed Single-FP Values"},
            {"MOVLHPS", "Move Packed Single-FP Values Low to High"},
            {"MOVLPD", "Move Low Packed Double-FP Value"},
            {"MOVLPS", "Move Low Packed Single-FP Values"},
            {"MOVMSKPD", "Extract Packed Double-FP Sign Mask"},
            {"MOVMSKPS", "Extract Packed Single-FP Sign Mask"},
            {"MOVNTDQ", "Store Double Quadword Using Non-Temporal Hint"},
            {"MOVNTI", "Store Doubleword Using Non-Temporal Hint"},
            {"MOVNTPD", "Store Packed Double-FP Values Using Non-Temporal Hint"},
            {"MOVNTPS", "Store Packed Single-FP Values Using Non-Temporal Hint"},
            {"MOVNTQ", "Store of Quadword Using Non-Temporal Hint"},
            {"MOVQ", "Move Quadword"},
            {"MOVQ2DQ", "Move Quadword from MMX Technology to XMM Register"},
            {"MOVS", "Move Data from String to String"},
            {"MOVSB", "Move Data from String to String"},
            {"MOVSD", "Move Scalar Double-FP Value"},
            {"MOVSHDUP", "Move Packed Single-FP High and Duplicate"},
            {"MOVSLDUP", "Move Packed Single-FP Low and Duplicate"},
            {"MOVSS", "Move Scalar Single-FP Values"},
            {"MOVSX", "Move with Sign-Extension"},
            {"MOVSXD", "Move with Sign-Extension"},
            {"MOVUPD", "Move Unaligned Packed Double-FP Value"},
            {"MOVUPS", "Move Unaligned Packed Single-FP Values"},
            {"MOVZX", "Move with Zero-Extend"},
            {"MPSADBW", "Compute Multiple Packed Sums of Absolute Difference"},
            {"MUL", "Unsigned Multiply"},
            {"MULPD", "Multiply Packed Double-FP Values"},
            {"MULPS", "Multiply Packed Single-FP Values"},
            {"MULSD", "Multiply Scalar Double-FP Values"},
            {"MULSS", "Multiply Scalar Single-FP Value"},
            {"MWAIT", "Monitor Wait"},
            {"NEG", "Two's Complement Negation"},
            {"NOP", "No Operation"},
            {"NOT", "One's Complement Negation"},
            {"OR", "Logical Inclusive OR"},
            {"ORPD", "Bitwise Logical OR of Double-FP Values"},
            {"ORPS", "Bitwise Logical OR of Single-FP Values"},
            {"OUT", "Output to Port"},
            {"OUTS", "Output String to Port"},
            {"OUTSB", "Output String to Port"},
            {"OUTSW", "Output String to Port"},
            {"PACKSSDW", "Pack with Signed Saturation"},
            {"PACKSSWB", "Pack with Signed Saturation"},
            {"PACKUSWB", "Pack with Unsigned Saturation"},
            {"PADDB", "Add Packed Integers"},
            {"PADDD", "Add Packed Integers"},
            {"PADDQ", "Add Packed Quadword Integers"},
            {"PADDSB", "Add Packed Signed Integers with Signed Saturation"},
            {"PADDSW", "Add Packed Signed Integers with Signed Saturation"},
            {"PADDUSB", "Add Packed Unsigned Integers with Unsigned Saturation"},
            {"PADDUSW", "Add Packed Unsigned Integers with Unsigned Saturation"},
            {"PADDW", "Add Packed Integers"},
            {"PALIGNR", "Packed Align Right"},
            {"PAND", "Logical AND"},
            {"PANDN", "Logical AND NOT"},
            {"PAUSE", "Spin Loop Hint"},
            {"PAVGB", "Average Packed Integers"},
            {"PAVGW", "Average Packed Integers"},
            {"PBLENDW", "Blend Packed Words"},
            {"PCMPEQB", "Compare Packed Data for Equal"},
            {"PCMPEQD", "Compare Packed Data for Equal"},
            {"PCMPEQW", "Compare Packed Data for Equal"},
            {"PCMPESTRI", "Packed Compare Explicit Length Strings, Return Index"},
            {"PCMPESTRM", "Packed Compare Explicit Length Strings, Return Mask"},
            {"PCMPGTB", "Compare Packed Signed Integers for Greater Than"},
            {"PCMPGTD", "Compare Packed Signed Integers for Greater Than"},
            {"PCMPGTW", "Compare Packed Signed Integers for Greater Than"},
            {"PCMPISTRI", "Packed Compare Implicit Length Strings, Return Index"},
            {"PCMPISTRM", "Packed Compare Implicit Length Strings, Return Mask"},
            {"PEXTRB", "Extract Byte"},
            {"PEXTRD", "Extract Dword/Qword"},
            {"PEXTRW", "Extract Word"},
            {"PINSRB", "Insert Byte"},
            {"PINSRD", "Insert Dword/Qword"},
            {"PINSRW", "Insert Word"},
            {"PMADDWD", "Multiply and Add Packed Integers"},
            {"PMAXSW", "Maximum of Packed Signed Word Integers"},
            {"PMAXUB", "Maximum of Packed Unsigned Byte Integers"},
            {"PMINSW", "Minimum of Packed Signed Word Integers"},
            {"PMINUB", "Minimum of Packed Unsigned Byte Integers"},
            {"PMOVMSKB", "Move Byte Mask"},
            {"PMULHUW", "Multiply Packed Unsigned Integers and Store High Result"},
            {"PMULHW", "Multiply Packed Signed Integers and Store High Result"},
            {"PMULLW", "Multiply Packed Signed Integers and Store Low Result"},
            {"PMULUDQ", "Multiply Packed Unsigned DW Integers"},
            {"POP", "Pop a Value from the Stack"},
            {"POPCNT", "Bit Population Count"},
            {"POPF", "Pop Stack into rFLAGS Register"},
            {"POPFQ", "Pop Stack into rFLAGS Register"},
            {"POR", "Bitwise Logical OR"},
            {"PREFETCHNTA", "Prefetch Data Into Caches"},
            {"PREFETCHT0", "Prefetch Data Into Caches"},
            {"PREFETCHT1", "Prefetch Data Into Caches"},
            {"PREFETCHT2", "Prefetch Data Into Caches"},
            {"PSADBW", "Compute Sum of Absolute Differences"},
            {"PSHUFD", "Shuffle Packed Doublewords"},
            {"PSHUFHW", "Shuffle Packed High Words"},
            {"PSHUFLW", "Shuffle Packed Low Words"},
            {"PSHUFW", "Shuffle Packed Words"},
            {"PSLLD", "Shift Packed Data Left Logical"},
            {"PSLLDQ", "Shift Double Quadword Left Logical"},
            {"PSLLQ", "Shift Packed Data Left Logical"},
            {"PSLLW", "Shift Packed Data Left Logical"},
            {"PSRAD", "Shift Packed Data Right Arithmetic"},
            {"PSRAW", "Shift Packed Data Right Arithmetic"},
            {"PSRLD", "Shift Double Quadword Right Logical"},
            {"PSRLDQ", "Shift Double Quadword Right Logical"},
            {"PSRLQ", "Shift Packed Data Right Logical"},
            {"PSRLW", "Shift Packed Data Right Logical"},
            {"PSUBB", "Subtract Packed Integers"},
            {"PSUBD", "Subtract Packed Integers"},
            {"PSUBQ", "Subtract Packed Quadword Integers"},
            {"PSUBSB", "Subtract Packed Signed Integers with Signed Saturation"},
            {"PSUBSW", "Subtract Packed Signed Integers with Signed Saturation"},
            {"PSUBUSB", "Subtract Packed Unsigned Integers with Unsigned Saturation"},
            {"PSUBUSW", "Subtract Packed Unsigned Integers with Unsigned Saturation"},
            {"PSUBW", "Subtract Packed Integers"},
            {"PUNPCKHBW", "Unpack High Data"},
            {"PUNPCKHDQ", "Unpack High Data"},
            {"PUNPCKHQDQ", "Unpack High Data"},
            {"PUNPCKHWD", "Unpack High Data"},
            {"PUNPCKLBW", "Unpack Low Data"},
            {"PUNPCKLDQ", "Unpack Low Data"},
            {"PUNPCKLQDQ", "Unpack Low Data"},
            {"PUNPCKLWD", "Unpack Low Data"},
            {"PUSH", "Push Word, Doubleword or Quadword Onto the Stack"},
            {"PUSHF", "Push rFLAGS Register onto the Stack"},
            {"PUSHFQ", "Push rFLAGS Register onto the Stack"},
            {"PXOR", "Logical Exclusive OR"},
            {"RCL", "Rotate"},
            {"RCPPS", "Compute Reciprocals of Packed Single-FP Values"},
            {"RCPSS", "Compute Reciprocal of Scalar Single-FP Values"},
            {"RCR", "Rotate"},
            {"RDMSR", "Read from Model Specific Register"},
            {"RDPMC", "Read Performance-Monitoring Counters"},
            {"RDTSC", "Read Time-Stamp Counter"},
            {"RDTSCP", "Read Time-Stamp Counter and Processor ID"},
            {"REP", "Repeat String Operation Prefix"},
            {"REPNZ", "Repeat String Operation Prefix"},
            {"REPZ", "Repeat String Operation Prefix"},
            {"RETF", "Return from procedure"},
            {"RETN", "Return from procedure"},
            {"REX", "Access to new 8-bit registers"},
            {"REXB", "Extension of r/m field, base field, or opcode reg field"},
            {"REXR", "Extension of ModR/M reg field"},
            {"REXRB", "REX.R and REX.B combination"},
            {"REXRX", "REX.R and REX.X combination"},
            {"REXRXB", "REX.R, REX.X and REX.B combination"},
            {"REXW", "64 Bit Operand Size"},
            {"REXWB", "REX.W and REX.B combination"},
            {"REXWR", "REX.W and REX.R combination"},
            {"REXWRB", "REX.W, REX.R and REX.B combination"},
            {"REXWRX", "REX.W, REX.R and REX.X combination"},
            {"REXWRXB", "REX.W, REX.R, REX.X and REX.B combination"},
            {"REXWX", "REX.W and REX.X combination"},
            {"REXWXB", "REX.W, REX.X and REX.B combination"},
            {"REXX", "Extension of SIB index field"},
            {"REXXB", "REX.X and REX.B combination"},
            {"ROL", "Rotate"},
            {"ROR", "Rotate"},
            {"ROUNDPD", "Round Packed Double-FP Values"},
            {"ROUNDPS", "Round Packed Single-FP Values"},
            {"ROUNDSD", "Round Scalar Double-FP Values"},
            {"ROUNDSS", "Round Scalar Single-FP Values"},
            {"RSM", "Resume from System Management Mode"},
            {"RSQRTPS", "Compute Recipr. of Square Roots of Packed Single-FP Values"},
            {"RSQRTSS", "Compute Recipr. of Square Root of Scalar Single-FP Value"},
            {"SAHF", "Store AH into Flags"},
            {"SAL", "Shift"},
            {"SAR", "Shift"},
            {"SBB", "Integer Subtraction with Borrow"},
            {"SCAS", "Scan String"},
            {"SETB", "Set Byte on Condition - below/not above or equal/carry (CF=1)"},
            {"SETBE", "Set Byte on Condition - below or equal/not above (CF=1 OR ZF=1)"},
            {"SETL", "Set Byte on Condition - less/not greater (SF!=OF)"},
            {"SETLE", "Set Byte on Condition - less or equal/not greater ((ZF=1) OR (SF!=OF))"},
            {"SETNB", "Set Byte on Condition - not below/above or equal/not carry (CF=0)"},
            {"SETNBE", "Set Byte on Condition - not below or equal/above (CF=0 AND ZF=0)"},
            {"SETNL", "Set Byte on Condition - not less/greater or equal (SF=OF)"},
            {"SETNLE", "Set Byte on Condition - not less nor equal/greater ((ZF=0) AND (SF=OF))"},
            {"SETNO", "Set Byte on Condition - not overflow (OF=0)"},
            {"SETNP", "Set Byte on Condition - not parity/parity odd (PF=0)"},
            {"SETNS", "Set Byte on Condition - not sign (SF=0)"},
            {"SETNZ", "Set Byte on Condition - not zero/not equal (ZF=0)"},
            {"SETO", "Set Byte on Condition - overflow (OF=1)"},
            {"SETP", "Set Byte on Condition - parity/parity even (PF=1)"},
            {"SETS", "Set Byte on Condition - sign (SF=1)"},
            {"SETZ", "Set Byte on Condition - zero/equal (ZF=1)"},
            {"SFENCE", "Store Fence"},
            {"SGDT", "Store Global Descriptor Table Register"},
            {"SHL", "Shift"},
            {"SHLD", "Double Precision Shift Left"},
            {"SHR", "Shift"},
            {"SHRD", "Double Precision Shift Right"},
            {"SHUFPD", "Shuffle Packed Double-FP Values"},
            {"SHUFPS", "Shuffle Packed Single-FP Values"},
            {"SIDT", "Store Interrupt Descriptor Table Register"},
            {"SLDT", "Store Local Descriptor Table Register"},
            {"SMSW", "Store Machine Status Word"},
            {"SQRTPD", "Compute Square Roots of Packed Double-FP Values"},
            {"SQRTPS", "Compute Square Roots of Packed Single-FP Values"},
            {"SQRTSD", "Compute Square Root of Scalar Double-FP Value"},
            {"SQRTSS", "Compute Square Root of Scalar Single-FP Value"},
            {"STC", "Set Carry Flag"},
            {"STD", "Set Direction Flag"},
            {"STI", "Set Interrupt Flag"},
            {"STMXCSR", "Store MXCSR Register State"},
            {"STOS", "Store String"},
            {"STOSB", "Store String"},
            {"STOSW", "Store String"},
            {"STOSD", "Store String"},
            {"STOSQ", "Store String"},
            {"STR", "Store Task Register"},
            {"SUB", "Subtract"},
            {"SUBPD", "Subtract Packed Double-FP Values"},
            {"SUBPS", "Subtract Packed Single-FP Values"},
            {"SUBSD", "Subtract Scalar Double-FP Values"},
            {"SUBSS", "Subtract Scalar Single-FP Values"},
            {"SWAPGS", "Swap GS Base Register"},
            {"SYSCALL", "Fast System Call"},
            {"SYSENTER", "Fast System Call"},
            {"SYSEXIT", "Fast Return from Fast System Call"},
            {"SYSRET", "Return From Fast System Call"},
            {"TEST", "Logical Compare"},
            {"TEST", "Logical Compare"},
            {"UCOMISD", "Unordered Compare Scalar Double-FP Values and Set EFLAGS"},
            {"UCOMISS", "Unordered Compare Scalar Single-FP Values and Set EFLAGS"},
            {"UD", "Undefined Instruction"},
            {"UD2", "Undefined Instruction"},
            {"UNPCKHPD", "Unpack and Interleave High Packed Double-FP Values"},
            {"UNPCKHPS", "Unpack and Interleave High Packed Single-FP Values"},
            {"UNPCKLPD", "Unpack and Interleave Low Packed Double-FP Values"},
            {"UNPCKLPS", "Unpack and Interleave Low Packed Single-FP Values"},
            {"VERR", "Verify a Segment for Reading"},
            {"VERW", "Verify a Segment for Writing"},
            {"VMCALL", "Call to VM Monitor"},
            {"VMCLEAR", "Clear Virtual-Machine Control Structure"},
            {"VMLAUNCH", "Launch Virtual Machine"},
            {"VMPTRLD", "Load Pointer to Virtual-Machine Control Structure"},
            {"VMPTRST", "Store Pointer to Virtual-Machine Control Structure"},
            {"VMREAD", "Read Field from Virtual-Machine Control Structure"},
            {"VMRESUME", "Resume Virtual Machine"},
            {"VMWRITE", "Write Field to Virtual-Machine Control Structure"},
            {"VMXOFF", "Leave VMX Operation"},
            {"VMXON", "Enter VMX Operation"},
            {"WBINVD", "Write Back and Invalidate Cache"},
            {"WRMSR", "Write to Model Specific Register"},
            {"XADD", "Exchange and Add"},
            {"XCHG", "Exchange Register/Memory with Register"},
            {"XGETBV", "Get Value of Extended Control Register"},
            {"XLAT", "Table Look-up Translation"},
            {"XOR", "Logical Exclusive OR"},
            {"XORPD", "Bitwise Logical XOR for Double-FP Values"},
            {"XORPS", "Bitwise Logical XOR for Single-FP Values"},
            {"XRSTOR", "Restore Processor Extended States"},
            {"XSAVE", "Save Processor Extended States"},
            {"XSETBV", "Set Extended Control Register"}};
}  // namespace sontag::tables
